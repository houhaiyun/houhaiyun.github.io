<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Peter's technology stack."><title>Docker 镜像管理 | Peter's technology stack.</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Docker/">Docker</a></div><div class="post-time">2018-07-21</div></div></div><div class="container post-header"><h1>Docker 镜像管理</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一-什么是Docker镜像"><span class="toc-number">1.</span> <span class="toc-text">一. 什么是Docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-rootfs"><span class="toc-number">1.1.</span> <span class="toc-text">1. rootfs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Docker镜像的主要特点"><span class="toc-number">1.2.</span> <span class="toc-text">2. Docker镜像的主要特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#分层"><span class="toc-number">1.2.1.</span> <span class="toc-text">分层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#写时复制"><span class="toc-number">1.2.2.</span> <span class="toc-text">写时复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#内容寻址"><span class="toc-number">1.2.3.</span> <span class="toc-text">内容寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#联合挂载"><span class="toc-number">1.2.4.</span> <span class="toc-text">联合挂载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、-Docker镜像的存储组织方式"><span class="toc-number">2.</span> <span class="toc-text">二、 Docker镜像的存储组织方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-registry"><span class="toc-number">2.1.</span> <span class="toc-text">1. registry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-repository"><span class="toc-number">2.2.</span> <span class="toc-text">2. repository</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-manifest"><span class="toc-number">2.3.</span> <span class="toc-text">3. manifest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-image和layer"><span class="toc-number">2.4.</span> <span class="toc-text">4. image和layer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Dockerfile"><span class="toc-number">2.5.</span> <span class="toc-text">5. Dockerfile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、Docker镜像构建操作"><span class="toc-number">3.</span> <span class="toc-text">三、Docker镜像构建操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-commit镜像"><span class="toc-number">3.1.</span> <span class="toc-text">1. commit镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-build构建镜像"><span class="toc-number">3.2.</span> <span class="toc-text">2. build构建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Docker-client端"><span class="toc-number">3.2.1.</span> <span class="toc-text">Docker client端</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#情况1：第一个参数为“-”，即"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">情况1：第一个参数为“-”，即</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#情况2：-第一个参数为URL，且是git-repository-URL，如"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">情况2： 第一个参数为URL，且是git repository URL，如</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#情况3：-第一个参数为URL，且不是git-repository-URL，则从该URL下载context，并将其封装为一个io流——io-Reader，后面的处理情况与情况1相同，只是将STDIN换为了io-Reader。"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">情况3： 第一个参数为URL，且不是git repository URL，则从该URL下载context，并将其封装为一个io流——io.Reader，后面的处理情况与情况1相同，只是将STDIN换为了io.Reader。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#情况4：-其他情况，即context为本地文件或目录的情况。"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">情况4： 其他情况，即context为本地文件或目录的情况。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Docker-server端"><span class="toc-number">3.2.2.</span> <span class="toc-text">Docker server端</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h3 id="一-什么是Docker镜像"><a href="#一-什么是Docker镜像" class="headerlink" title="一. 什么是Docker镜像"></a>一. 什么是Docker镜像</h3><p>Docker镜像是一个只读的Docker容器模板，含有启动Docker容器所需的文件系统结构及其内容，因此启动一个Docker容器的基础。Docker镜像的文件内容以及一些运行的Docker容器的配置文件组成了Docker容器的静态文件系统运行环境——rootfs。可以这么理解，Docker镜像是Docker容器的静态视角，Docker容器是Docker镜像的运行状态。</p>
<a id="more"></a>
<h4 id="1-rootfs"><a href="#1-rootfs" class="headerlink" title="1. rootfs"></a>1. rootfs</h4><p>rootfs是Docker容器在启动时内部进程可见的文件系统，即Docker容器的根目录。rootfs通常包含一个操作系统运行所需的文件系统，例如可能包含典型的类Unix操作系统中的目录系统，如/dev、/proc、/bin、/etc、/lib、/usr、/tmp及运行Docker容器所需的配置文件、工具等。</p>
<p>在传统的Linux操作系统内核启动时，首先挂载一个只读（read-only）的rootfs，当系统给检测其完整性之后，再将其切换为读写（read-write）模式。而在Docker架构中，当Docker daemon为Docker容器挂载rootfs时，沿用了Linux内核启动时的方法，即将rootfs设为只读模式。再挂载完毕之后，利用联合挂载（union mount）技术在已有的只读rootfs再挂载一个读写层，只有再Docker容器运行过程中文件系统发生变化时，才会把变化的文件内容写到可读可写层，并隐藏只读层中的老版本文件。</p>
<h4 id="2-Docker镜像的主要特点"><a href="#2-Docker镜像的主要特点" class="headerlink" title="2. Docker镜像的主要特点"></a>2. Docker镜像的主要特点</h4><h5 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h5><p>Docker镜像时采用分层的方式构建的，每个镜像都由一系列的“镜像层”组成。分层结构是Docker镜像如此轻量的重要原因，当需要修改容器镜像内的某个文件时，只对处于最上方的读写曾进行变动，不覆写下层已有的文件系统内容，已有文件在只读层的原版本仍然存在，但会被读写曾中的新版文件所隐藏。当使用docker commit提交这个修改过的容器文件系统为一个新的镜像时，保存的内容仅为最上层读写文件系统中被更新过的文件。分层达到了在不同镜像之间共享镜像层的效果。</p>
<h5 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h5><p>Dockerr镜像使用写时复制（copy-on-write）策略，在多个容器之间共享镜像，每个容器在启动的时候并不需要单独复制一份镜像文件，而是将所有镜像层以只读的方式挂载到一个挂载点，再在上面覆盖一个可读可写的容器层。在未更改文件内容时，所有容器共享同一份数据，只有在Docker容器运行过程中文件系统发生变化时，才会把变化的文件内容写到可读写层，并隐藏只读层中的老版本文件。写时复制配合分层机制减少了镜像对磁盘空间的占用和容器启动时间。</p>
<h5 id="内容寻址"><a href="#内容寻址" class="headerlink" title="内容寻址"></a>内容寻址</h5><p>在Docker 1.10版本后，Docker镜像改动较大，其中最重要的特性便是引入了内容寻址存储（content-addressable storage）的机制，根据文件内容来索引镜像和镜像层。与之前版本对每一个镜像层随机生成一个UUID不同，新模型对镜像层的内容计算校验和，生成一个内容哈希值，并以此哈希值替代之前的UUID作为镜像层的唯一标志。该机制主要提高了镜像的安全性，并在pull、push、load和save操作后的检测数据的完整性。另外，基于内容哈希来索引镜像层，在一定程度上减少了ID的冲突并且增强了镜像层的共享。对于来自不同的构建的镜像层，只要拥有相同的内容哈希，也能被不同的镜像共享。</p>
<h5 id="联合挂载"><a href="#联合挂载" class="headerlink" title="联合挂载"></a>联合挂载</h5><p>通俗地讲，联合挂载技术可以在一个挂载点挂载多个文件系统，将挂载点的原目录与被挂载内容进行整合，使得最终可见的文件系统将会包含整合之后的各层的文件和目录。实现这种联合挂载技术的文件系统通常被称为联合文件系统（union filesystem）。</p>
<p>联合挂载是用于将多个镜像层的文件系统挂载到一个挂载点来实现一个统一文件系统视图的途径，是下层存储驱动（如aufs、overlay等）实现分层合并的方式。所以严格来说，来奶和挂载并不是Docker镜像的必需技术，比如我们在使用Device Mapper存储驱动时，其实是使用了快照技术来达到分层的效果，没有联合挂载这一概念。</p>
<h3 id="二、-Docker镜像的存储组织方式"><a href="#二、-Docker镜像的存储组织方式" class="headerlink" title="二、 Docker镜像的存储组织方式"></a>二、 Docker镜像的存储组织方式</h3><p>上一节从概念上讲解了Docker镜像，本节将介绍Docker镜像的关键概念，为深入理解Docker镜像实现原理做好铺垫。</p>
<h4 id="1-registry"><a href="#1-registry" class="headerlink" title="1. registry"></a>1. registry</h4><p>我们知道，每个Docker容器都从Docker镜像生成。俗话说，“巧妇难为无米之炊”，当使用docker run命令启动一个容器时，从哪里获取需要的镜像呢？答案是，如果头一次基于某个镜像启动容器，宿主上并不存在需要的镜像，那么Docker将从registry中下载该镜像并保存到宿主机；否则，直接从宿主机镜像完成启动。那么，registry是什么呢？</p>
<p>registry用以保存Docker镜像，其中还包括镜像层级结构和关于镜像的元数据。可以将registry简单地想象成类似于Git仓库之类的实体。</p>
<p>用户可以在自己的数据中心搭建私有的registry，也可以使用Docker官方的公用registry服务，及Docker Hub。它是由Docker公司维护的一个公共镜像仓库，供用户下载使用。Docker Hub中由两种类型的仓库。即用户仓库（user repository）与顶层仓库（top-level repository）。用户仓库由普通的Docker Hub用户创建，顶层仓库则由Docker公司负责维护，提供官方版本镜像。理论是，顶层仓库中的镜像经过Docker公司验证，被认为是架构良好且安全的。</p>
<h4 id="2-repository"><a href="#2-repository" class="headerlink" title="2. repository"></a>2. repository</h4><p>repository即由具有某个功能的Docker镜像的所有迭代版本构成的景象组。由上文可知，registry由一系类经过命名的repository组成，repository通过命名规范对用户仓库和顶层仓库进行组织。用户仓库的命名由用户名和repository名两部分组成，中间以“/”隔开，即username/repository_name的形式，repository名通常表示镜像所具有的功能，如ansible/ubuntu14.04-ansible；而顶层仓库只包含repository名的部分，如ubuntu。</p>
<p>读者也许会产生疑问，通常将ubuntu视为镜像名称，这里却解释为repository，那么repository和镜像之间是说明关系呢？事实上，repository是一个镜像集合，其中包含了多个不同版本的镜像，使用标签进行版本区分，如ubuntu:14.04、ubutnu:12.04等，它们均属于ubuntu这个repository。</p>
<p>一言以屏之，registry是repository的集合，repository是镜像的集合。</p>
<h4 id="3-manifest"><a href="#3-manifest" class="headerlink" title="3. manifest"></a>3. manifest</h4><p>manifest（描述文件）主要存在于registry中作为Docker镜像的元数据文件，在pull、push、save和load中作为镜像结构和基础信息的描述文件。在镜像被pull或者load到Docker宿主机时，manifest被转换为本地的镜像配置文件config。新版本（v2，schema 2）的manifest list可以组合不同架构实现同名Docker镜像的manifest，用以支持多架构Docker镜像。</p>
<h4 id="4-image和layer"><a href="#4-image和layer" class="headerlink" title="4. image和layer"></a>4. image和layer</h4><p>Docker内部的image概念是用来存储一组镜像相关的元数据信息，主要包括镜像的架构（如amd64）、镜像默认配置信息、构建镜像的容器配置信息、包含所有镜像层信息的rootfs。Docker利用rootfs中的diff_id计算出内容寻址的索引（chainID）来获取layer相关信息，进而获取每一个镜像层的文件内容。</p>
<p>layer（镜像层）是一个Docker用来管理镜像层的中间概念，本节前面提到镜像是由镜像层组成的，而单个镜像层可能被多个镜像共享，所以Docker将layer与image的概念分离。Docker镜像管理中的layer主要存放了镜像层的diff_id、size、cache-id和parent等内容，实际的文件内容则是由存储驱动来管理，并可以通过cache-id在本地索引到。</p>
<h4 id="5-Dockerfile"><a href="#5-Dockerfile" class="headerlink" title="5. Dockerfile"></a>5. Dockerfile</h4><p>Dockerfile是在通过docker build命令构建自己的Docker镜像时需要使用到的定义文件。它允许用户使用基本的DSL语法来定义Docker镜像，每一条指令描述了构建镜像的步骤。</p>
<h3 id="三、Docker镜像构建操作"><a href="#三、Docker镜像构建操作" class="headerlink" title="三、Docker镜像构建操作"></a>三、Docker镜像构建操作</h3><p>Docker提供了比较简单的方式来构建镜像或者更新现有的镜像——docker build和docker commit。不过原则上讲，用户并不能“无中生有”地创建一个镜像，无论是启动一个容器或者构建一个镜像，都是在其他镜像基础上进行的，Docker有一些列镜像被称为基础镜像（如基础Ubuntu镜像ubuntu、基础Fedora镜像fedora等），基础镜像便是镜像构建的起点。不同的是，docker commit是将容器提交为一个镜像，也就是从容器更新或者构建镜像；而docker build是在一个镜像的基础上构建镜像。</p>
<h4 id="1-commit镜像"><a href="#1-commit镜像" class="headerlink" title="1. commit镜像"></a>1. commit镜像</h4><p>docker commit命令只提交容器镜像发生变更了的部分，即修改后的容器镜像与当前仓库中对应镜像之间的差异部分，这使得该操作实际需要提交的文件往往并不多。</p>
<p>Docker daemon接收到对应的HTTP请求后，需哟啊执行的步骤如下。</p>
<ul>
<li>(1) 根据用户输入pause参数的设置确定是否暂停该Docker容器的运行</li>
<li>(2) 将容器的可读可写层导出打包，该读写层代表了当前运行容器的文件系统与当初启动该容器的镜像之间的差异。</li>
<li>(3) 在层存储（layerStore）中注册可读可写差异包</li>
<li>(4) 更新镜像历史信息和rootfs，并据此在镜像存储（imageStore）中创建一个新的镜像，记录其元数据。</li>
<li>(5) 如果指定了repository信息，则给上述镜像添加tag信息。</li>
</ul>
<h4 id="2-build构建镜像"><a href="#2-build构建镜像" class="headerlink" title="2. build构建镜像"></a>2. build构建镜像</h4><p>一般来说，用户主要使用Dockerfile和docker build命令来完成一个新镜像的构建。这条命令的格式如下；</p>
<p>Usage: docker build [OPTIONS]  PATH | URL | -</p>
<p>其中PATH或URL所指向的文件称为context（上下文），context包含build Docker镜像过程中需要的的Dockerfile以及其他的资源文件。下面介绍该命令的执行流程。</p>
<h5 id="Docker-client端"><a href="#Docker-client端" class="headerlink" title="Docker client端"></a>Docker client端</h5><p>当Docker client接收到用户命令，首先解析命令行参数。根据第一个参数的不同，将分为以下4种情况分别处理。</p>
<h6 id="情况1：第一个参数为“-”，即"><a href="#情况1：第一个参数为“-”，即" class="headerlink" title="情况1：第一个参数为“-”，即"></a>情况1：第一个参数为“-”，即</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#从STDIN种输入Dockerfile，没有context。</span><br><span class="line">$ sudo docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#从STDIN种读入压缩的context</span><br><span class="line">$ sudo docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>
<p>此时，则根据命令行输入参数对Dockerfile和context进行设置。</p>
<h6 id="情况2：-第一个参数为URL，且是git-repository-URL，如"><a href="#情况2：-第一个参数为URL，且是git-repository-URL，如" class="headerlink" title="情况2： 第一个参数为URL，且是git repository URL，如"></a>情况2： 第一个参数为URL，且是git repository URL，如</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build github.com/creack/docker-firefox</span><br></pre></td></tr></table></figure>
<p>则调用git clone –depth 1 –recursive命令克隆该GitHub repository，该操作会在本地的一个临时目录中进行，命令成功之后该目录将作为context传给Docker daemon，该目录中的Dockerfile会被用来进行后续构建Docker镜像。</p>
<h6 id="情况3：-第一个参数为URL，且不是git-repository-URL，则从该URL下载context，并将其封装为一个io流——io-Reader，后面的处理情况与情况1相同，只是将STDIN换为了io-Reader。"><a href="#情况3：-第一个参数为URL，且不是git-repository-URL，则从该URL下载context，并将其封装为一个io流——io-Reader，后面的处理情况与情况1相同，只是将STDIN换为了io-Reader。" class="headerlink" title="情况3： 第一个参数为URL，且不是git repository URL，则从该URL下载context，并将其封装为一个io流——io.Reader，后面的处理情况与情况1相同，只是将STDIN换为了io.Reader。"></a>情况3： 第一个参数为URL，且不是git repository URL，则从该URL下载context，并将其封装为一个io流——io.Reader，后面的处理情况与情况1相同，只是将STDIN换为了io.Reader。</h6><h6 id="情况4：-其他情况，即context为本地文件或目录的情况。"><a href="#情况4：-其他情况，即context为本地文件或目录的情况。" class="headerlink" title="情况4： 其他情况，即context为本地文件或目录的情况。"></a>情况4： 其他情况，即context为本地文件或目录的情况。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#使用了当前文件夹作为context</span><br><span class="line">$ sudo docker build -t vieux/apache:2.0 .</span><br></pre></td></tr></table></figure>
<p>如果目录中有.dockerignore文件，则将context中文件名满足其定义的规则的文件都从上传列表中排除，不打包传给Docker daemon。但唯一的例外是.dockerignore文件中误写入了.dockerignore本身或者Dockerfile，将不会产生作用。如果定义了tag，则对其指定的repository和tag进行验证。</p>
<p>完成了相关信息的设置之后，Docker client向Docker server发送POST/build的HTTP请求，包含了所需的context信息。</p>
<h5 id="Docker-server端"><a href="#Docker-server端" class="headerlink" title="Docker server端"></a>Docker server端</h5><p>Docker server接收到相应的HTTP请求后，需要做的工作如下。</p>
<ul>
<li>(1) 创建一个临时目录，并将context指定的文件系统解压到该目录下。</li>
<li>(2) 读取并解析Dockerfile。</li>
<li>(3) 根据解析出的Dockerfile遍历其中的所有指令，并分发到不同的模块去执行。Dockerfile每条指令的格式均为INSTRUCTION arguments，INSTRUCTION是一些特定的关键词，包括FROM、RUN、USER等，都会映射到不同的parser进行处理。</li>
<li>(4) parser为上述每一个指令创建一个对应的临时容器，在临时容器中执行当前指令，然后通过commit使用此容器生成一个镜像层。</li>
<li>(5) Dockerfile中所有的指令对应的层的集合，就是此次build后的结果。如果指定了tag参数，便给镜像打上对应的tag。最后一次commit生成的镜像ID就会作为最终的镜像ID返回。</li>
</ul>
<p>综上所述，本节从概念阐述与源码分析两个角度深入刨析了镜像技术在Docker架构中的应用，相信读者也对如何与DOcker镜像交互有了自己的见解。当然，由于Docker镜像是构建Docker服务的基础，相关的命令还远远不止此，等待读者亲手实践。而在上述镜像功能的分析和梳理中其涉及很多关于镜像文件和目录的操作，这一部分跟底层的存储驱动比如aufs是息息相关的。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>