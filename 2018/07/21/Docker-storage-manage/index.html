<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Peter's technology stack."><title>Docker 存储管理 | Peter's technology stack.</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Docker/">Docker</a></div><div class="post-time">2018-07-21</div></div></div><div class="container post-header"><h1>Docker 存储管理</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-存储管理"><span class="toc-number">1.</span> <span class="toc-text">Docker 存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#存储驱动Device-Mapper"><span class="toc-number">1.1.</span> <span class="toc-text">存储驱动Device Mapper</span></a></li></ol></li></ol></details></div><div class="container post-content"><h3 id="Docker-存储管理"><a href="#Docker-存储管理" class="headerlink" title="Docker 存储管理"></a>Docker 存储管理</h3><p>Dcoker拥有写镜像分层与写时复制机制，为了支持这些特性，Docker提供了存储驱动的接口。存储驱动根据操作系统底层的支持提供了针对某种文件系统的初始化操作以及对镜像层的增、删、改、查和差异比较等操作。目前存储系统的接口已有aufs、btrfs、devicemapper、vfs、overlay、zfs这6种具体实现，其中vfs不支持写时复制，是为使用volume提供的存储驱动，仅仅做了简单的文件瓜子啊操作；剩下5种存储驱动支持写时复制，它们的实现有一定的相似之处。</p>
<a id="more"></a>
<h4 id="存储驱动Device-Mapper"><a href="#存储驱动Device-Mapper" class="headerlink" title="存储驱动Device Mapper"></a>存储驱动Device Mapper</h4><p>Device Mapper是Linux 2.6内核中提供的一种逻辑设备到物理设备的映射框架机制，在该机制下，用户可以很方便地更具自己的需要指定实现存储资源的管理策略。</p>
<p>简单来说，Device Mapper包括3个概念：映射设备、映射表和目标设备。映射设备是内核向外提供的逻辑设备。一个映射设备通过一个映射表与多个目标设备映射起来，映射表包含了多个多元组，每个多元组记录了这个映射设备的其实地址、范围与一个目标设备的地址偏移量的映射关系。目标设备可以是一个物理设备，也可以是一个映射设备，这个映射设备可以继续向下迭代。印个映射设备最终通过一棵映射树映射到物理设备上。Device Mapper本hi功能就是根据映射关系描述IO处理规则，当映射设备接收到IO请求的时候，这个IO请求会根据映射表逐级转发，直到这个请求最终传到最底层的物理设备上。</p>
<p>Docker下面的devicemapper存储驱动式使用Device Mapper的精简配置（thin-provisioning）和快照（snapshotting）功能实现镜像分层。这个模块使用了两个块设备（一个用于存储数据，另一个用于存储元数据），并将其构建成一个资源池（thin pool）用以创建其他存储镜像的块设备。数据区为生成其他块设备提供资源，元信息存储了虚拟设备和物理设备的映射关系。Copy on Write发生在块存储级别。devicemapper在构建一个资源池后，会先创建一个有文件系统的基础设备，再通过从已有设备创建快照的方式创建新的设备，这些新创建的块设备在写入内容之前并不会分配资源。所有的容器层和镜像层都有自己的块设备，均是通过其父镜像层创建快照的方式来创建（没有父镜像层的层从基础设备创建快照）。</p>
<p>值得说明的是，devicemapper存储驱动根据使用的两个基础块设备是真正的块设备还是稀疏文件挂载的loop设备分为两种模式，前者称为direct-lvm模式，后者是Docker默认的loop-lvm模式。两种方式对于配置的好的Docker用户来说是完全透明的，驱动层的工作方式也一致，但由于底层存储方式不同导致两者性能差别很大。考虑到loop-lvm不需要额外配置的易用性，Docker将其作为deicemapper的默认模式，但在生产环境中，推荐使用direct-lvm模式。</p>
<p>在已经创建好两个块设备的基础上，要使用direct-lvm模式的devicemaper存储驱动，需要在Docker daemon启动的时候除了添加-s=devicemapper参数外，还要下列的参数指定存储数据和原数据的块设备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--storage-opt dm.datadev=/path/to/data</span><br><span class="line">--storage-opt dm.metadatadev=/path/to/metadata</span><br></pre></td></tr></table></figure>
<p>如果使用过devicemapper存储驱动，在/var/lib/docker/下会创建devicemapper/以及image/devicemapper目录。同样，image/devicemapper也是存储了镜像和逻辑镜像层的元数据信息。</p>
<p>最终，具体的文件都会存储在/var/lib/docker/devicemapper文件夹下，这个文件夹下有3个子文件夹，其中mnt为设备挂载目录，devicemapper文件夹下，这个文件夹下有3个子文件夹，其中mnt为设备挂载目录，devicemaper下存储了loop-lvm模式下的两个稀疏文件，metadata下存储了每个块设备驱动层的元数据信息。</p>
<p>以loop-lvm模式为例，在devicemapper实际查看一下，可以看到data是一个100GB的稀疏文件，它包含了所有镜像和容器的实际文件内容，是整个资源池的默认大小。每一个容器默认被限制在10GB大小的卷内，可以通过重新启动daemon，并添加参数–storage-opt dm.basesize=[size]调整急促块设备的大小，原有镜像层以及在原有镜像基础上创建的容器层的大小限制不受影响，只有在更改参数后pull下来的基础上创建的容器才会生效，并且basesize只能比原来的大，否则daemon会报错。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>