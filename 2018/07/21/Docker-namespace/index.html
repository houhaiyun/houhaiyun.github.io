<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Peter" />



<meta name="description" content="namespace 资源隔离Docker大热之后，热衷技术的开发者就会思考，想要实现一个资源隔离的容器，应该从哪些方面下手？也许第一反应就是chroot命令，这条命令给用户最直观的感受就是再使用后根目录/的挂载点切换了，即文件系统被隔离了。接着，为了在分布式的环境下进行通信和定位，容器必须要有独立的IP、端口、路由等，自然就联想到了网络的隔离。同时，容器还需要一个独立的主机名以便在网络中标识自己。">
<meta name="keywords" content="Docker">
<meta property="og:type" content="article">
<meta property="og:title" content="namespace资源隔离">
<meta property="og:url" content="https://www.ihaiyun.cc/2018/07/21/Docker-namespace/index.html">
<meta property="og:site_name" content="Peter&#39;s technology stack.">
<meta property="og:description" content="namespace 资源隔离Docker大热之后，热衷技术的开发者就会思考，想要实现一个资源隔离的容器，应该从哪些方面下手？也许第一反应就是chroot命令，这条命令给用户最直观的感受就是再使用后根目录/的挂载点切换了，即文件系统被隔离了。接着，为了在分布式的环境下进行通信和定位，容器必须要有独立的IP、端口、路由等，自然就联想到了网络的隔离。同时，容器还需要一个独立的主机名以便在网络中标识自己。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://houhaiyun.github.io/img/images/Docker-1.png">
<meta property="og:image" content="https://houhaiyun.github.io/img/images/Docker-2.png">
<meta property="og:image" content="https://houhaiyun.github.io/img/images/Docker-3.png">
<meta property="og:image" content="https://houhaiyun.github.io/img/images/Docker-4.png">
<meta property="og:image" content="https://houhaiyun.github.io/img/images/Docker-5.png">
<meta property="og:updated_time" content="2018-07-21T11:07:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="namespace资源隔离">
<meta name="twitter:description" content="namespace 资源隔离Docker大热之后，热衷技术的开发者就会思考，想要实现一个资源隔离的容器，应该从哪些方面下手？也许第一反应就是chroot命令，这条命令给用户最直观的感受就是再使用后根目录/的挂载点切换了，即文件系统被隔离了。接着，为了在分布式的环境下进行通信和定位，容器必须要有独立的IP、端口、路由等，自然就联想到了网络的隔离。同时，容器还需要一个独立的主机名以便在网络中标识自己。">
<meta name="twitter:image" content="https://houhaiyun.github.io/img/images/Docker-1.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">




    <link rel="shortcut icon" href="/favicon.png">





    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">




<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>namespace资源隔离 | Peter&#39;s technology stack.</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: false,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Peter</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Keep learn!</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="true" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/houhaiyun" title="GitHub"></a>
                            
                                <a class="fa Twitter" href="https://twitter.com/houhaiyun18?lang=zh-cn" title="Twitter"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">小生姓侯，名海云，河北人。性豁达，善言谈，平家子也。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Peter</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Peter</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Keep learn!</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/about" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/houhaiyun" title="GitHub"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/houhaiyun18?lang=zh-cn" title="Twitter"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-Docker-namespace" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/21/Docker-namespace/" class="article-date">
      <time datetime="2018-07-21T11:05:12.000Z" itemprop="datePublished">2018-07-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      namespace资源隔离
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/容器/">容器</a><a class="article-category-link" href="/categories/容器/namespace资源隔离/">namespace资源隔离</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="namespace-资源隔离"><a href="#namespace-资源隔离" class="headerlink" title="namespace 资源隔离"></a>namespace 资源隔离</h3><p>Docker大热之后，热衷技术的开发者就会思考，想要实现一个资源隔离的容器，应该从哪些方面下手？也许第一反应就是chroot命令，这条命令给用户最直观的感受就是再使用后根目录/的挂载点切换了，即文件系统被隔离了。接着，为了在分布式的环境下进行通信和定位，容器必须要有独立的IP、端口、路由等，自然就联想到了网络的隔离。同时，容器还需要一个独立的主机名以便在网络中标识自己。有了网络，自然离不开通信，也就想到了进程间通信需要隔离。开发者可能也已想到了权限的问题，对用户和用户组的隔离就实现了用户权限的隔离。最后，运行在容器中的应用需要有进程号（PID），自然也需要与宿主机中的PID进行隔离。</p>
<a id="more"></a>
<p>由此，基本上完成了一个容器所需要做的6项隔离，Linux内核中提供了这6中namespace隔离的系统调用，如下表。当然，真正的容器还需要处理许多其他工作。</p>
<table>
<thead>
<tr>
<th style="text-align:center">namespace</th>
<th style="text-align:center">系统调用参数</th>
<th style="text-align:center">隔离内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UTS</td>
<td style="text-align:center">CLONE_NEWUTS</td>
<td style="text-align:center">主机名与域名</td>
</tr>
<tr>
<td style="text-align:center">IPC</td>
<td style="text-align:center">CLONE_NEWIPC</td>
<td style="text-align:center">信号量、消息队列和共享内存</td>
</tr>
<tr>
<td style="text-align:center">PID</td>
<td style="text-align:center">CLONE_NEWPID</td>
<td style="text-align:center">进程编号</td>
</tr>
<tr>
<td style="text-align:center">Network</td>
<td style="text-align:center">CLONE_NEWNET</td>
<td style="text-align:center">网络设备、网络栈、端口等</td>
</tr>
<tr>
<td style="text-align:center">Mount</td>
<td style="text-align:center">CLONE_NEWNS</td>
<td style="text-align:center">挂载点（文件系统）</td>
</tr>
<tr>
<td style="text-align:center">User</td>
<td style="text-align:center">CLONE_NEWUSER</td>
<td style="text-align:center">用户和用户组</td>
</tr>
</tbody>
</table>
<p>实际上，Linux内核实现namespace的一个主要目的，就是实现轻量级虚拟化（容器）服务。在同一个namespace下的进程可以感知彼此的变化，而对外界的进程一无所知。这样就可以让容器中的进程产生错觉，仿佛自己置身于一个独立的系统环境中，以达到独立和隔离的目的。</p>
<p>需要说明的是，本节所讨论的namespace实现针对的均是Linux内核3.8及以后的版本。接下来，将首先介绍使用namespace的API，然后对这6种namespace进行逐一讲解，并通过程序让读者切身感受隔离效果。</p>
<h4 id="1-进行namespace-API的四种方式"><a href="#1-进行namespace-API的四种方式" class="headerlink" title="1. 进行namespace API的四种方式"></a>1. 进行namespace API的四种方式</h4><p>namespace的API包括clone()、sents()以及unshare()，还有/proc下的部分文件。为了确定隔离的到底是哪6项namespace，在使用这些API时，通常需要指定以下6个参数中的一个或多个，通过|（位或）操作来实现。从表1-1可知，这6个参数分别是CLONE_NEWIPC、CLONE_NEWNS、CLONE_NEWNET、CLONE_NEWPID、CLONE_NEWUSER和CLONE_NEWUTS。</p>
<h5 id="通过clone-在创建新进程的同时创建namespace"><a href="#通过clone-在创建新进程的同时创建namespace" class="headerlink" title="通过clone()在创建新进程的同时创建namespace"></a>通过clone()在创建新进程的同时创建namespace</h5><p>使用clone()来创建一个独立namespace的进程，是最常见的做法，也是Docker使用namespace最基本的方法，它的调用方式如下。</p>
<p>int clone(int (<em>child_func)(void </em>), void <em>child_stack, int flags, void </em>arg);</p>
<p>clone()实际上是Linux系统调用fork()的一种更通用的实现方式，它可以通过flags来控制使用多少功能。一共有20多种CLONE_*的flag（标志位）参数用来控制clone进程的方方面面（如是否与夫进程共享虚拟内存等），下面挑选与namespace相关的4个参数进行说明。</p>
<ul>
<li>child_func传入子进程运行的程序的主函数。</li>
<li>child_stack传入子进程使用的栈空间</li>
<li>flags表示使用哪些CLONE_*标志位，与namespace相关的主要包括CLONE_NEWIPC、CLONE_NEWNS、CLONE_NEWNET、CLONE_NEWPID、CLONE_NEWUSER和CLONE_NEWUTS。</li>
<li>args则可用于传入用户参数</li>
</ul>
<h5 id="查看-proc-pid-ns文件"><a href="#查看-proc-pid-ns文件" class="headerlink" title="查看/proc/[pid]/ns文件"></a>查看/proc/[pid]/ns文件</h5><p>从3.8版本的内核开始，用户就可以在/proc/[pid]/ns文件下看到指向不同namespace号的文件，效果如下所示，形如[4026531838]者集为namespace号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# ll /proc/$$/ns/		&lt;&lt;-- $$是shell中表示当前运行的进程ID号</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月   9 11:21 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月   9 11:21 mnt -&gt; mnt:[4026532767]</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月   9 11:21 net -&gt; net:[4026531968]</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月   9 11:21 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月   9 11:21 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 7月   9 11:21 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure>
<p>如果两个进程指向的namespace编号相同，就说明它们在同一个namespace下，否者便在不同的namespace里面。/proc/[pid]/ns里设置这些Link的另外一个作用是，一旦上述link文件被打开，只要打开的文件描述符（fd）存在，那么就算该namespace下的所有进程都已经结束，这个namespace也会一直存在，后续的进程也可以再加入进来。在Docker中，通过文件描述符定位和加入一个存在的namespace是最基本的方式。</p>
<p>另外，把/proc/[pid]/ns目录文件使用–bind方式挂载起来可以起到同样的作用，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># touch ~/uts</span><br><span class="line"># mount --bind /proc/145690/ns/uts ~/uts</span><br></pre></td></tr></table></figure>
<p>为了方便起见，后面的讲解中会使用这个~/uts文件来代替/proc/145690/ns/uts</p>
<p>注意：如果读者看到ns下的内容与本节所述不符，那可能是因为使用了3.8以前版本的内核。如在内核版本2.6中，该目录下存在的只有ipc、net和uts，并且以硬链接方式存在。</p>
<h5 id="通过setns-加入一个已经存在的namespace"><a href="#通过setns-加入一个已经存在的namespace" class="headerlink" title="通过setns()加入一个已经存在的namespace"></a>通过setns()加入一个已经存在的namespace</h5><p>上文提到，在进程都结束的情况下，也可以通过挂载的形式把namespace保留下来，保留namespace的目的是为以后有进程加入做准备。在Docker中，使用docker exec命令在已经运行着的容器中执行以一个新命令，就需要用到该方法。通过setns()系统调用，进程从原先的namespace加入某个已经存在的namespace，使用方法如下。通常为了不影响进程的调用者，也为了是新加入的pid namespace生效，会在setns()函数执行后使用clone()创建子进程继续执行命令，让原先的进程结束运行。</p>
<p>int setns(int fd,int nstype);</p>
<ul>
<li>参数fd表示要加入namespace的文件描述符。上文提到，它是一个指向/proc/[pid]/ns目录的文件描述符，可以通过直接打开该目录下的链接或者打开一个挂载了该目录下的链接文件得到。</li>
<li>参数nstype让调用者可以检查fd指向的namespace类型是否符合实际要求。该参数为0表示不检查。</li>
</ul>
<p>为了把新加入的namespace利用起来，需要引入execve()系列函数，该函数可以执行用户命令，最常用的就是调用/bin/bash并接受参数，运行一个shell，用法如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = open(argv[1], 0_RDONLY);	/* 获取namespace文件描述符 */</span><br><span class="line">setns(fd,0);	/* 加入新的namespace */</span><br><span class="line">execvp(argv[2],&amp;argv[2]);	/* 执行程序 */</span><br></pre></td></tr></table></figure>
<p>假设编译后的程序名称为setns-test</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ./setns-test ~/uts /bin/bash # ~/uts 是绑定的/proc/145690/ns/uts</span><br></pre></td></tr></table></figure>
<p>至此，就可以在新加入的namespace中执行shell命令了，下文会多次使用这种方式来演示隔离的效果。</p>
<h5 id="通过unshare-在原先进程上进行namespace隔离"><a href="#通过unshare-在原先进程上进行namespace隔离" class="headerlink" title="通过unshare()在原先进程上进行namespace隔离"></a>通过unshare()在原先进程上进行namespace隔离</h5><p>最后要说明的系统调用是unshare()，它与clone()很像，不同的是，unshare()运行在原先的进程上，不需要启动一个新进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int unshare(int flags);</span><br></pre></td></tr></table></figure>
<p>调用unshare()的主要作用就是，不启动新进程就可以起到隔离的效果，相当于跳出原先的namespace进行操作。这样，就可以在原进程进行一些需要隔离的操作。Linux中自带的unshare命令，就是通过unshare()系统调用实现的。Docker目前并没有使用这个系统调用，这里不做展开，读者可以自行查阅资料学习该命令的知识。</p>
<h6 id="fore-系统调用"><a href="#fore-系统调用" class="headerlink" title="fore()系统调用"></a>fore()系统调用</h6><p>系统调用函数fork()并不术语namespace的API，这部分属于延伸阅读，如果读者已经对fork()有足够多的了解，可以忽略该部分。</p>
<p>当程序调用fork()函数时，系统会创建新的进程，为其分配资源，例如存储数据和代码的空间，然后把原来进程的所有值都复制到新进程中，只有少量署至与原来的进程值不同，相当于复制了本身。那么程序的后续代码逻辑要如何区分自己是新进程还是父进程呢？</p>
<p>fork()的神奇之处在于它仅仅被调用一次，却能够返回两次（父进程与子进程各返回一次），通过返回值的不同就可以区分夫进程与子进程。它可能有以下3中不同的返回值：</p>
<ul>
<li>在父进程中，fork()返回创建子进程的进程ID；</li>
<li>在子进程中，fork()返回0；</li>
<li>如果出现错误，fork()返回一个负值。</li>
</ul>
<p>下面给出一段代码，命名为fork_example.c。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main ()&#123;</span><br><span class="line">	pid_t fpid; // fpid表示fork函数返回的值</span><br><span class="line">	int count=0;</span><br><span class="line">	fpid=fork();</span><br><span class="line">	if (fpid &lt; 0)printf(&quot;error in fork!&quot;);</span><br><span class="line">	else if (fpid == 0) &#123;</span><br><span class="line">		printf(&quot;I am child. Process id is %d\n&quot;,getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		printf(&quot;i am parent. Process id is %d\n&quot;,getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并执行，结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# gcc -Wall fork_example.c &amp;&amp; ./a.out</span><br><span class="line">i am parent. Process id is 125009</span><br><span class="line">I am child. Process id is 125010</span><br></pre></td></tr></table></figure>
<p>代码执行过程中，在语句fpid=fork()之前，只有一个进程在执行这段代码，在这条语句之后，就编程夫进程和子进程同时执行了。这两个进程几乎完全相同，将执行的下一条语句都是if(fpid&lt;0)，同时fpid=fork()的返回值会依据所属进程返回不同的值。</p>
<p>使用fork()后，夫进程有义务监控子进程的运行状态，并在子进程退出后自己才能正常退出，否则子进程就会成为“孤儿”进程。</p>
<p>下面将根据Docker内部对namespace资源隔离使用的方式分别对6种namespace进行详细的解析。</p>
<h4 id="2-UTS-namespace"><a href="#2-UTS-namespace" class="headerlink" title="2. UTS namespace"></a>2. UTS namespace</h4><p>UTS（UNIX Time-sharing System）namespace提供了主机名和域名的隔离，这样每个Docker容器就可以拥有独立的主机名和域名了，在网络上可以被视作一个独立的节点，而非宿主上的一个进程。Docker种，每个镜像基本都以自身所提供的服务名称来命令镜像的hostname，且不会对宿主机产生任何印象，其原理就是利用了UTS namespace。</p>
<p>下面通过代码来感受以下UTS隔离的效果，首先需要一个程序的骨架。打开编辑器创建uts.c文件，输入如下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line"></span><br><span class="line">static char child_stack[STACK_SIZE];</span><br><span class="line">char* const child_args[] = &#123;</span><br><span class="line">    &quot;/bin/bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int child_main(void* args) &#123;</span><br><span class="line">    printf(&quot;在子进程中!\n&quot;);</span><br><span class="line">    execv(child_args[0],child_args);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;程序开始：\n&quot;);</span><br><span class="line">    int child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD, NULL);</span><br><span class="line">    waitpid(child_pid, NULL, 0);</span><br><span class="line">    printf(&quot;已退出\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行上述代码，执行如下命令，效果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# gcc -Wall uts.c -o uts.o</span><br><span class="line">[root@node1 test]# ./uts.o </span><br><span class="line">程序开始：</span><br><span class="line">在子进程中!</span><br><span class="line">[root@node1 test]# exit</span><br><span class="line">exit</span><br><span class="line">已退出</span><br></pre></td></tr></table></figure>
<p>下面将修改代码，加入UTS隔离。运行代码需要root权限，以防止普通用户随意修改系统主机名导致set-user-ID相关的应用运行出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# vim namespace.c </span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line"></span><br><span class="line">static char child_stack[STACK_SIZE];</span><br><span class="line">char* const child_args[] = &#123;</span><br><span class="line">    &quot;/bin/bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int child_main(void* args) &#123;</span><br><span class="line">    printf(&quot;在子进程中!\n&quot;);</span><br><span class="line">    sethostname(&quot;NewNamespace&quot;, 12);</span><br><span class="line">    execv(child_args[0],child_args);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;程序开始：\n&quot;);</span><br><span class="line">    int child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD, NULL);</span><br><span class="line">    waitpid(child_pid, NULL, 0);</span><br><span class="line">    printf(&quot;已退出\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行，就可以看到hostname已经变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# gcc -Wall namespace.c -o main.o &amp;&amp; ./main.o</span><br><span class="line">程序开始：</span><br><span class="line">在子进程中!</span><br><span class="line">[root@NewNamespace test]# exit</span><br><span class="line">exit</span><br><span class="line">已退出</span><br><span class="line">[root@node1 test]#		&lt;- 回到原来的hostname</span><br></pre></td></tr></table></figure>
<p>值得一提的是，也许有读者会尝试不加CLONE_NEWUTS参数运行上述代码，发现主机名同样改变了，并且输入exit后主机名也恢复了，似乎并没有区别。实际上，不加CLONE_NEWUTS参数进行隔离时，由于使用sethostname函数，所以宿主机的主机名被修改了。而看到exit退出后主机名还原，是因为bash只是在刚登录时读取一次UTS，不会实时获取最新的主机名。当重新登录或者使用uname命令进行查看时，就会发现产生的变化。</p>
<h4 id="3-IPC-namespace"><a href="#3-IPC-namespace" class="headerlink" title="3. IPC namespace"></a>3. IPC namespace</h4><p>进程间通信（Inter-Process Communitcation，IPC）涉及的IPC资源包括常见的信号量、消息队列和共享内存。申请IPC资源就申请了一个全局唯一的32位ID，所有IPC namespace中实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，不同的IPC namespace下的进程则互相不可见。</p>
<p>IPC namespace在实现代码上与UTS namespace相似，只是标识位有所变化，需要加上CLONE_NEWIPC参数。主要改动如下，其他部分不变，程序名称改为ipc.c。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# vim ipc.c </span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line"></span><br><span class="line">static char child_stack[STACK_SIZE];</span><br><span class="line">char* const child_args[] = &#123;</span><br><span class="line">    &quot;/bin/bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int child_main(void* args) &#123;</span><br><span class="line">    printf(&quot;在子进程中!\n&quot;);</span><br><span class="line">    sethostname(&quot;NewNamespace&quot;, 12);</span><br><span class="line">    execv(child_args[0],child_args);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;程序开始：\n&quot;);</span><br><span class="line">    int child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWIPC | CLONE_NEWUTS | SIGCH</span><br><span class="line">LD, NULL);    waitpid(child_pid, NULL, 0);</span><br><span class="line">    printf(&quot;已退出\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在shell中使用ipcmk -Q命令创建一个message queue。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# ipcmk -Q</span><br><span class="line">消息队列 id：32769</span><br></pre></td></tr></table></figure>
<p>通过ipcs -q可以查看到已经开启的message queue，序号为32769。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# ipcs -q</span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息         </span><br><span class="line">0x630a5186 32769      root       644        0            0</span><br></pre></td></tr></table></figure>
<p>然后可以编译运行加入了IPC namespace隔离的ipc.c，在新建的子进程中调用shell中执行的ipcs -q查看你message queue。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# gcc -Wall ipc.c -o ipc.o &amp;&amp; ./ipc.o</span><br><span class="line">程序开始：</span><br><span class="line">在子进程中!</span><br><span class="line">[root@NewNamespace test]# ipcs -q</span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息      </span><br><span class="line"></span><br><span class="line">[root@NewNamespace test]# exit</span><br><span class="line">exit</span><br><span class="line">已退出</span><br></pre></td></tr></table></figure>
<p>从结果显示中可以发现，子进程找不到原先声明的message queue了，已经实现了IPC的隔离。</p>
<p>从结果显示中可以发现，子进程找不到原先声明的message queue了，已经实现了IPC的隔离。</p>
<p>目前使用IPC namespace机制的系统不多，启动比较有名的有PostgreSQL。Docker当前也使用了IPC namespace是实现了容器与宿主机、容器与容器之间的IPC隔离。</p>
<h4 id="4-PID-namespace"><a href="#4-PID-namespace" class="headerlink" title="4. PID namespace"></a>4. PID namespace</h4><p>PID namespace 隔离非常使用，他对进程PID重新标号，即两个不同namespace下的进程可以有相同的PID。每个PID namespace都有自己的计数程序。内核为所有的PID namespace维护了一个树状结构，最顶层时系统初始时创建的，被称为root namespace。它创建的新PID namespace被称为child namespace（树的子节点），而原先的PID namespace就是新创建的PID namespace就是新创建的PID namespace的parent namespace（树的父节点）。通过这种方式，不同的PID namespaces会形成一个层级体系。所属的父节点可以看到子节点中的进程，并可以通过信号等方式对子节点中的而进程产生影响。反过来，子节点却不能看到父节点PID namespace中的任何内容，由此产生如下结论。</p>
<ul>
<li>每个PID namespace中的第一个进程 “PID 1”，都会像传统Linux中的init进车给一样拥有特权，起到特殊作用。</li>
<li>一个namespace中的进程，不可能通过kill或ptrace影响父节点或者兄弟节点中的进程，因为其他节点的PID在这个namespace中没有任何意义。</li>
<li>如果你在新的PID namespace中重新挂载/proc文件系统，会发现其下只显示同属于一个PID namespace中的其他进程。</li>
<li>在root namespace中可以看到所有的进程，并且递归包含所有子节点中的进程。</li>
</ul>
<p>到这里，读者可能已经联想到一种在外部监控Docker中运行程序的方法了，就是监控Docker daemon所在的PID namespace下的所有进程及其子进程，再进行筛选即可。</p>
<p>下面通过运行代码来感受一下PID namespace的隔离效果。修改上文的代码，加入PID namespace的标识位，并把程序命名改为pid.c。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# vim pid.c </span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line"></span><br><span class="line">static char child_stack[STACK_SIZE];</span><br><span class="line">char* const child_args[] = &#123;</span><br><span class="line">    &quot;/bin/bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int child_main(void* args) &#123;</span><br><span class="line">    printf(&quot;在子进程中!\n&quot;);</span><br><span class="line">    sethostname(&quot;NewNamespace&quot;, 12);</span><br><span class="line">    execv(child_args[0],child_args);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;程序开始：\n&quot;);</span><br><span class="line">    int child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWIPC | CLONE_NEWPID | CLONE</span><br><span class="line">_NEWUTS | SIGCHLD, NULL);    waitpid(child_pid, NULL, 0);</span><br><span class="line">    printf(&quot;已退出\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行后可以看到如下结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# gcc -Wall pid.c -o pid.o &amp;&amp; ./pid.o </span><br><span class="line">程序开始：</span><br><span class="line">在子进程中!</span><br><span class="line">[root@NewNamespace test]# echo $$</span><br><span class="line">1</span><br><span class="line">[root@NewNamespace test]# exit</span><br><span class="line">exit</span><br><span class="line">已退出</span><br></pre></td></tr></table></figure>
<p>打印$$可以看到shell的PID，退出后如果再次执行可以看到效果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# echo $$</span><br><span class="line">139020</span><br></pre></td></tr></table></figure>
<p>已经回到了正常状态。有的读者可能在子进程的shell中执行了ps aus/top之类的命令，发现还是可以看到所有父进程的PID，那是因为还没有对文件系统挂载点进行隔离，ps/top之类的命令调用的时真实系统下的/proc文件内容，看到的自然是所有的进程。所有，与其他的namespace不同的时，为了实现一个稳定安全的容器，PID namespace还需要进行一些额外的工作才能确保运行顺利，下面将逐一介绍。</p>
<h5 id="PID-namespace中的init进程"><a href="#PID-namespace中的init进程" class="headerlink" title="PID namespace中的init进程"></a>PID namespace中的init进程</h5><p>在传统的Unix系统中，PID为1的进程时init，地位非常特殊。它作为所有进程的父进程，维护一张进程表，不断检查进程的状态，一旦有某个子进程因为父进程错误成为了“孤儿进程”，init就会扶着收养这个子进程并最终回收资源，结束进程。所以在要实现的容器中，启动的第一个进车给也需要实现类似init的功能，维护所有后续启动进程的运行状态。</p>
<p>当系统中存在树状嵌套结构的PID namespace时，若某个子进程成为孤儿进程，收养孩子进程的责任就交给了该子进程所属的PID namespace中的init进程。</p>
<p>至此，可能读者已经明白了内核设计的良苦用心。PID namespace维护这样一个树状结构，有利于系统的资源监控与回收。因此，如果确实需要一个Docker容器内运行多个进程，最先启动的命令进车给应该时具有资源监控和回收的个管理能力的，如bash。</p>
<h6 id="信号与init进程"><a href="#信号与init进程" class="headerlink" title="信号与init进程"></a>信号与init进程</h6><p>内核还未PID namespace中的init进程赋予了其他特权——信号屏蔽。如果init中没有编写处理某个信号的代码逻辑，那么与init在同一个PID namespace下的进程（即使有超级权限）发送给它的该信号都会被屏蔽。这个功能的主要作用是方式init进程被误杀。</p>
<p>那么，父节点PID namespace中的进程发送同样的信号给子节点中的init进程，这会被忽略吗？父节点中的集成发送的信号，如果不似乎SIGKILL（销毁进程）或SIGSTOP（暂停进程）也会被忽略。但如果发送SIGKILL或SIGSTOP，子节点的init会强制执行（无法通过代码捕捉进行特殊处理），也就是说父节点中的进程有权终止子节点中的进程。</p>
<p>一旦init进程被销毁，同一PID namespace中的其他进程也随之接收到SIGKILL信号而被销毁。理论上，该PID namespace也不复存在了。但是如果/proc/[pid]/ns/pid处于被挂载或者打开状态，namespace就会被保留下来。然而，保留下来的namespace无法通过setns()或者fork()创建进程，所以实际上并没有什么作用。</p>
<p>当一个容器内存在多个进程时，容器内的init进程可以对信号进行捕获，当SIGTERM或SIGINT等信号到来时，对其子进程做信息保存、资源回收等处理工作。在Docker daemon的源码中也可以看到类似的处理方式，当结束信号来临时，结束容器进程并回收相应资源。</p>
<h6 id="挂载proc文件系统"><a href="#挂载proc文件系统" class="headerlink" title="挂载proc文件系统"></a>挂载proc文件系统</h6><p>前文提到，如果在新的PID namespace中使用ps命令查看，看到的还是所有的进程，因为与PID直接相关的/proc文件系统（procfs）没有挂载到一个与源/proc不同的位置。如果只想看到与PID namespace本身应该看到的进程，需要重新挂载/proc，命令如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# ./pid.o </span><br><span class="line">程序开始：</span><br><span class="line">在子进程中!</span><br><span class="line">[root@NewNamespace test]# mount -t proc /proc</span><br><span class="line">[root@NewNamespace test]# ps a</span><br><span class="line">   PID TTY      STAT   TIME COMMAND</span><br><span class="line">     1 pts/0    S      0:00 /bin/bash</span><br><span class="line">    18 pts/0    R+     0:00 ps a</span><br><span class="line">[root@NewNamespace test]# exit</span><br><span class="line">exit</span><br><span class="line">已退出</span><br></pre></td></tr></table></figure>
<p>可以看到实际的PID namespace就只有两个进程在运行。</p>
<blockquote>
<p>注意：此时并没有进行mount namespace的隔离，所以该操作实际上已经影响了root namespace的文件系统。当推出新建的PID namespace以后，再执行ps a时，就会发现出错，再次执行mount -t proc proc /proc可以修复错误。后面还会介绍通过mount namespace来隔离文件系统，当我们基于mount namespace实现了proc文件系统隔离后，我们就能在Docker容器中使用ps等命令看到与PID namespace对应的进程列表。</p>
</blockquote>
<h6 id="unshare-和setns"><a href="#unshare-和setns" class="headerlink" title="unshare()和setns()"></a>unshare()和setns()</h6><p>本章开头就谈到了unshare()和setns()这两个API，在PID namespace中使用时，也有一些特别之处需要注意。</p>
<p>unshare()允许用户在原有进程中建立命名空间进行隔离。但创建了PID namespace后，原先unshare()调用者进程并不进入新的PID namespace，接下来创建的子进程才会进入新的namespace，这个子进程也就随之成为新的namespace中的init进程。</p>
<p>类似地，调用setns()创建新的PID namespace时，调用者进程也不进入新的PID namespace，而是随后创建的子进程进入。</p>
<p>为什么创建其他namespace时unshare()和setns()回直接进入新的namespace，而唯独PID namespace例外呢？因为调用getpid()函数得到的PID是根据调用者所在的PID namespace而决定返回哪个PID，进入新的PID namespace会导致PID产生变化。而对用户态的程序和库函数来说，它们都认为进程的PID是一个常量，PID的变化会引起这些进程崩溃。</p>
<p>换句话说，一旦程序进程创建以后，那么它的PID namespace的关系就确定下来了，进程不会变更它们对应的PID namespace。在Docker中，docker exec会使用setns()函数加入已经存在的命名空间，但是最终还是会调用clone()函数，原因就在于此。</p>
<h4 id="5-mount-namespace"><a href="#5-mount-namespace" class="headerlink" title="5. mount namespace"></a>5. mount namespace</h4><p>mount namespace通过隔离文件系统挂载点对隔离文件系统提供支持，他是历史上第一个Linux namespace，所以标识位比较特殊，就是CLONE_NEWNS。隔离后，不同mount namespace中的文件结构发生变化也互不影响。可以通过/proc/[pid]/mounts查看到所有挂载在当前namespace中的文件系统，还可以通过/proc/[pid]/mountstats看到mount namespace中文件设备的统计信息，包括挂载文件的名字、文件系统类型、挂载位置等。</p>
<p>进程在创建mount namespace时，会把当前的文件结构复制给新的namespace。新的namespace中的所有moount操作都只影响自身的文件系统，对外界不会产生任何影响。这种做法非常严格地实现了隔离，但对某些情况可能并不适用。比如父节点namespace中的进程挂载了一张CD-ROM，这时子节点namespace复制的目录结构是无法自动挂载上这张CD-ROM的，因为这种操作会影响到父节点的文件系统功能。</p>
<p>2006年引入的挂载传播（mount propagation）解决了这个问题，挂载传播定义了挂载对象（mount object）之前的关系，这样的关系包括共享关系和从属关系，系统用这些关系决定任何挂载对象中的挂载事件如何传播到其他挂载对象。</p>
<ul>
<li>共享关系（share relationship）。如果两个挂载对象具有共享关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，反之亦然。</li>
<li>从属关系（slave relationship）。如果两个挂载对象形成从属关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，但是反之不行；在这种关系中，从属对象是事件的接收者。</li>
</ul>
<p>一个挂载状态可能为以下一种：</p>
<ul>
<li>共享挂载（share）</li>
<li>从属挂载（slave）</li>
<li>共享/从属挂载（shared and slave）</li>
<li>私有挂载（private）</li>
<li>不可绑定挂载（unbindable）</li>
</ul>
<p>传播事件的挂载对象称为共享挂载；接收传播事件的挂载对象称为从属挂载；同时兼有前述两者特征的挂载对象称为共享/从属挂载；既不传播也不接收传播事件的挂载对象称为私有挂载；另一种特殊的挂载对象称为不可绑定的挂载，它们与私有挂载相似，但是不允许绑定挂载，即创建mount namespace时这块文件对象不可被复制。通过图1-1可以更好地了解它们的状态变化。</p>
<center><img src="https://houhaiyun.github.io/img/images/Docker-1.png" title="图1-1 mount各类挂载状态示意图"></center>

<p>下面我们以图1-1为例说明常用的挂载传播方式。最上层的mount namespace下的/bin目录与child namespace通过master slave方式进行挂载传播，当mount namespace中的/bin目录发生变化时，发生的挂载事件能够自动传播到child namespace中；/lib目录使用完全的共享挂载传播，各namespace之间发生的变化都会互相影响；/proc目录使用私有挂载传播的方式，各mount namespace之间互相隔离；最后的/root目录一般都是管理员所有，不能让其他mount namespace挂载绑定。</p>
<p>默认情况下，所有的挂载状态都是私有的。设置为共享挂载的命令如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-shared &lt;mount-object&gt;</span><br></pre></td></tr></table></figure>
<p>从共享挂载状态的挂载对象克隆的挂载对象，其状态也是共享，它们相互传播挂载事件。</p>
<p>设置为从属挂载的命令如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-slave &lt;shared-mount-object&gt;</span><br></pre></td></tr></table></figure>
<p>来源于从属挂载对象克隆的挂载对象也是从属的挂载，它也从属于原来的从属挂载的主挂载对象。</p>
<p>将一个从属挂载对象设置为共享/从属挂载，可以执行如下命令，或者将其移动到一个共享挂载对象下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-shared &lt;slave-mount-object&gt;</span><br></pre></td></tr></table></figure>
<p>如果想把修改过的挂载对象重新标记为私有的，可以执行如下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-private &lt;mount-object&gt;</span><br></pre></td></tr></table></figure>
<p>通过执行以下命令，可以将挂载对下岗标记为不可绑定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-unbindable &lt;mount-object&gt;</span><br></pre></td></tr></table></figure>
<p>这些设置都可以递归式地应用到所有子目录中，如果读者感兴趣可以自行搜索相关命令。</p>
<p>在代码中实现mount namespace隔离与其他namespace类似，加上CLONE_NEWNS标识位即可。让我再次修改代码，并且另存为mount.c进行编译运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 test]# cat mount.c</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line"></span><br><span class="line">static char child_stack[STACK_SIZE];</span><br><span class="line">char* const child_args[] = &#123;</span><br><span class="line">    &quot;/bin/bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int child_main(void* args) &#123;</span><br><span class="line">    printf(&quot;在子进程中!\n&quot;);</span><br><span class="line">    sethostname(&quot;NewNamespace&quot;, 12);</span><br><span class="line">    execv(child_args[0],child_args);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;程序开始：\n&quot;);</span><br><span class="line">    int child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWIPC | CLONE_NEWNS | CLONE_</span><br><span class="line">NEWPID | CLONE_NEWUTS | SIGCHLD, NULL);    waitpid(child_pid, NULL, 0);</span><br><span class="line">    printf(&quot;已退出\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CLONE_NEWNS生效之后，子进程进行的挂载与卸载操作都将只作用于这个mount namespace，因此在上文中提到的处于单独PID namespace隔离的进程中再加上mount namespace的隔离之后，即使该进程重新挂载了/proc文件系统，当进程退出后，root mount namespace（主机）的/proc文件系统是不会被破坏的。</p>
<h4 id="6-network-namespace"><a href="#6-network-namespace" class="headerlink" title="6. network namespace"></a>6. network namespace</h4><p>当我们了解完各类namespace，兴致勃勃地构建出一个容器，并在容器中启动一个Apache进程时，却出现了“80端口已被占用”的错误，原来主机上已经运行了一个Apache进程，这时就需要借助network namespac而技术进行网络隔离。</p>
<p>network namespace主要提供了关于网络资源的隔离，包括网络设备、IPv4和IPv6协议栈、IP路由表、防火墙、/proc/net目录、/sys/class/net目录、套接字（socker）等。一个物理的网络设备最多存在于一个network namespace中，可以通过创建veth pair（虚拟网络设备对：有两端，类似管道，如果数据从一端传入另一端也能接受到，反之亦然）在不同的network namespace间创建通道，以达到通信目的。</p>
<p>一般情况下，物理离网络设备都分配在最初的root namespace（表示系统默认的namespace）中。但是如果有多块物理网卡，也可以把其中一块或多块给新创建的network namespace。需要注意的是，当新创建的network namespace被释放时（所有内部的进程都终止并且namespace文件没有被挂载或打开），在这个namespace中的物理网卡会返回到root namespace，而非创建该进程的父进程所在的network namespace。</p>
<p>当说到network namespace时，指的未必是真正的网络隔离，而是把网络独立出来，给外部用户一种透明的感觉，仿佛在于一个独立网络实体进行通信。为例达到该目的，容器的经典做法就是创建俺一个veth pair，一端放置在新的namespace中，通常命名为eth0，一段放在原先的namespace中连接物理网络设备，再通过多个设备接入网桥或者进行路由转发啊，来实现通信的目的。</p>
<p>也许读者会好奇，在建立起veth pair之前，新旧namespace如何通信呢？答案是pipe（管道）。以Docker daemon启动容器的过程为例，假设容器内初始化的进程称为init。Docker daemon在宿主机上负责创建这个veth pair，把一端绑定到docker0王桥上，另一端接入新建的network namespace进程中。这个过程期间，Docker daemon和init就通过pipe进行通信。具体来说，就是在Docker daemon完成veth pair的创建之前，init在管道的另一端循环等待，知道管道另一端传来Docker daemon关于veth设备的信息，并关闭管道。init才结束等待的过程，并把它的“eth0”启动起来。整个结构如图1-2所示。</p>
<center><img src="https://houhaiyun.github.io/img/images/Docker-2.png" title="图1-2 Docker网络示意图"></center>

<p>与其他namespace类似，对network namespace的使用其实就是在创建的时候添加CLONE_NEWNET标识位。后续会详细讲解，此处不在赘述。</p>
<h4 id="7-user-namespace"><a href="#7-user-namespace" class="headerlink" title="7. user namespace"></a>7. user namespace</h4><p>user namespace主要隔离了安全相关的标识符（identifier）和属性（attribute），包括用户ID、用户组ID、root目录、key（指密码）以及特殊权限。通俗地讲，一个普通用户的进程通过clone()创建的新进程在新user namespace中可以拥有不同的用户和用户组。这意味着一个进程在容器外属于一个没有特权的普通用户，但是它创建的容器进程却属于拥有所有权限的超级用户，这个技术为容器提供了极大的自由。</p>
<p>user namespace时目前的6各namespace中最后一个支持的，并且直到Linux内核3.8版本的时候还未完全实现（还有部分文件系统不支持）。user namespace实际上并不算完全成熟，很多发行版担心安全问题，在编译内核的时候还未开启USER_NS。Docker在1.10版本中对user namespace进行了支持。只要用户在启动Docker daemon的时候指定了–user-remap，那么当用户运行容器时，容器内部的root用户并不等于宿主机内的root用户，而是映射到宿主机上的普通用户。在进行接下来的代码实验时，请确保系统的Linux内核版本高于3.8并且内核编译时开启了USER_NS（如果不会悬着，请使用Ubuntu14.04）。</p>
<p>Linux中，特权用户的user ID就是0，延时的最后将看到user ID非0的进程启动user namespace后user ID可以变为0.使用user namespace的方法根别的namespace相同，即调用cone()或unshare()时加入CLONE_NEWUSER标识位。修改代码并另存为userns.c，为例看到用户权限（Capabilities），还需要安装licap-devel包。</p>
<p>首先包含以下头文件以调用Capabilities包。</p>
<p>#include &lt;sys/capability.h&gt;</p>
<p>首次在子进程函数中加入geteuid()和getegid()得到namespace内部的user ID，通过cap_get_proc()得到当前进程的用户拥有的权限，并通过cap_to_text()输出。</p>
<p>此次实验没有成功，把原书内容贴出来吧。</p>
<center><img src="https://houhaiyun.github.io/img/images/Docker-3.png" title="user namespace实验"></center>

<p>通过验证可以得到以下信息。</p>
<ul>
<li>user namespace被创建后，第一个进程被赋予了该namespace中的全部权限，这样该init进程就可以完成所有必要的初始化工作，而不会因权限不足出现错误。</li>
<li>从namespace内部观察到的UID和GID已经与阿文i不不同了，默认显示为65534，表示尚未与外部namespace用户映射。此时需要对user namespace内部的这个初始user和它外部namespace的某个用户建立映射，这样可以保证当涉及一些对外部namespace的操作时，系统可以检验其权限（比如发送一个信号或操作某个文件）。同样用户组也要建立映射。</li>
<li>还有一点虽然不能哦才能够输出中发现，但却值得注意。用户在新namespace中有全部权限，但它在创建它的父namespace中不包含任何权限，就算调用和创建它的进程有全部权限也是如此。因此哪怕时root用户调用了clone()在user namespace中创建出的新用户，在外部也没有任何权限。</li>
<li>最后，user namespace的创建其实是一个层层嵌套的树状结构。最上层的根节点就是root namespace，新创建的每个user namespace都有一个父节点user namespace，以及零个或多个子节点user namespace，这一点与PID namespace非常相似。</li>
</ul>
<p>从图1-3中可以看到，namespace实际上就是按层次关联起来，每个namespace都发源于最初的root namespace并与之建立映射。</p>
<center><img src="https://houhaiyun.github.io/img/images/Docker-4.png" title="图1-3 namespace映射图"></center>

<p>接下来就要进行用户绑定操作，通过在/proc/[pid]/uid_map和/proc/[pid]/gid_map两个文件中写入对应的绑定信息就可以实现这一点，格式如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID-inside-ns ID-outside-ns length</span><br></pre></td></tr></table></figure>
<p>写这两个文件时需要注意以下几点。</p>
<ul>
<li>这两个文件只允许由拥有该user namespace中CAP_SETUP权限的进程写入一次，不允许修改。</li>
<li>写入的进程必须是该user namespace的父namespace或者子namespace。</li>
<li>第一字段ID-inside-ns表示新建的user namespace中对应的user/group ID，第二个字段ID-outside-ns表示namespace外部映射的user/group ID。最后一个字段表示映射范围，通常填1，表示只映射一个，如果填大于1的值，则按顺序建立一一映射。</li>
</ul>
<p>明白了上述原理，再次修改代码，添加设置uid和gid的函数。</p>
<center><img src="https://houhaiyun.github.io/img/images/Docker-5.png" title="修改代码"></center>

<p>至此，就已经完成了绑定的工作，可以看到演示全程都是在普通用户下执行的，最终实现了在user namespace中成为root用户，对应到外部则是一个uid为1000的普通用户。</p>
<p>如果要把user namespace与其他namespace混合使用，那么依旧需要root权限。解决方案是以普通用户身份创建user namespace，然后在新建的namespace中作为root，在clone()进程加入其他类型的namespace隔离。</p>
<p>讲解完user namespace，再来谈谈Docker。Docker不仅使用了user namespace，还使用了在user namespace中涉及的Capabilities机制。从内核2.2版本开始，Linux把原来和超级用户相关的高级权限划分为不同的安源，称为Capability。这样管理员就可以独立对特定的Capability进行使用或禁止。Docker同时使用user namespace和Capability，这在很大程度上加强了容器的安全性。</p>
<p>说到安全，namespace的6项隔离看似全面，实际上依旧没有完全隔离Linux的资源，比如SELinux、cgroups以及/sys、/proc/sys、/dev/sd*等目录下的资源。关于安全，将会在后续内容中进一步探讨。</p>
<p>本节从namespace使用的API开始，街斗Docker逐步对6各namespace进行了讲解。相信把讲解过程中所有的代码整合起来，读者也能实现一个属于自己的“shell”容器了。虽然namespace技术使用非常简单，但要真正把容器做到安全易用却并非易事。PID namespace中，需要实现一个完善的init进程来维护好所有进程；network namespace中，还有复杂的路由表和iptables规则没有配置；user namespace中还有许多权限问题需要考虑。其中的某些方面Docker已经做得不错，而且有些方面才刚刚起步，这些内容会在后续中详细介绍。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/07/21/Docker-namespace/">namespace资源隔离</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Peter</a></p>
        <p><span>发布时间:</span>2018-07-21, 11:05:12</p>
        <p><span>最后更新:</span>2018-07-21, 11:07:43</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/07/21/Docker-namespace/" title="namespace资源隔离">https://www.ihaiyun.cc/2018/07/21/Docker-namespace/</a>
            <span class="copy-path" data-clipboard-text="原文: https://www.ihaiyun.cc/2018/07/21/Docker-namespace/　　作者: Peter" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/07/21/Docker-cgroups/">
                    cgroups资源限制
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/07/21/Docker-harbor/">
                    使用vmware harbor构建镜像仓库
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#namespace-资源隔离"><span class="toc-number">1.</span> <span class="toc-text">namespace 资源隔离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-进行namespace-API的四种方式"><span class="toc-number">1.1.</span> <span class="toc-text">1. 进行namespace API的四种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#通过clone-在创建新进程的同时创建namespace"><span class="toc-number">1.1.1.</span> <span class="toc-text">通过clone()在创建新进程的同时创建namespace</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#查看-proc-pid-ns文件"><span class="toc-number">1.1.2.</span> <span class="toc-text">查看/proc/[pid]/ns文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通过setns-加入一个已经存在的namespace"><span class="toc-number">1.1.3.</span> <span class="toc-text">通过setns()加入一个已经存在的namespace</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通过unshare-在原先进程上进行namespace隔离"><span class="toc-number">1.1.4.</span> <span class="toc-text">通过unshare()在原先进程上进行namespace隔离</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#fore-系统调用"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">fore()系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-UTS-namespace"><span class="toc-number">1.2.</span> <span class="toc-text">2. UTS namespace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-IPC-namespace"><span class="toc-number">1.3.</span> <span class="toc-text">3. IPC namespace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-PID-namespace"><span class="toc-number">1.4.</span> <span class="toc-text">4. PID namespace</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PID-namespace中的init进程"><span class="toc-number">1.4.1.</span> <span class="toc-text">PID namespace中的init进程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#信号与init进程"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">信号与init进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#挂载proc文件系统"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">挂载proc文件系统</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#unshare-和setns"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">unshare()和setns()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-mount-namespace"><span class="toc-number">1.5.</span> <span class="toc-text">5. mount namespace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-network-namespace"><span class="toc-number">1.6.</span> <span class="toc-text">6. network namespace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-user-namespace"><span class="toc-number">1.7.</span> <span class="toc-text">7. user namespace</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-6 i,
        .toc-level-6 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>





    
        <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC8zMTE1MS83NzAw">
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/07/21/Docker-cgroups/" title="上一篇: cgroups资源限制">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/07/21/Docker-harbor/" title="下一篇: 使用vmware harbor构建镜像仓库">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/01/28/Docker-Catalog/">置顶  Docker文章目录</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/21/Linux-ClamAV/">linux杀毒软件ClamAV</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/21/Nginx-Jump-Accord-Phone/">Nginx根据手机电脑进行不同跳转</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/21/Nginx-Built-in-Variable/">NGINX内置变量参数详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/Other-1/">良好的用户体验几句箴言</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/Linux-Random-Password/">常用生成随机密码的方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/Linux-ls/">ls 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/Nginx-http-realip/">ngx_http_realip_moudle模块获取用户真实IP地址</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/Linux-Delete-M/">Linux删除文件的^M</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/Nginx-Module-Geoip/">Nginx之GeoIP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/Nginx-Module-Recommend/">Nginx模块推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/Prestashop-Deploy/">部署Prestashop_1.7.4.3</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/Web-Waiting-TTFB/">网站加载 Waiting (TTFB) 时间过长的原因和解决办法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/PHP-Make-GraphBed/">PHP制作简单图床</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/Supervisor/">Supervisor管理dotnet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/Nmap/">Nmap</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/RabbitMQ-Deploy/">部署RabbitMQ</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/Lucene-query/">Lucene查询语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/computer-book/">计算机开放电子书汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/Nginx-OpenResty/">OpenResty 介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/Nginx-Compile-lua/">Nginx编译lua</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/lua/">lua语言教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/05/Git-Gitlab-Deploy/">部署 gitlab</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/Nginx-ngx-cache-purge/">Nginx编译并添加ngx_cache_purge模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/Nginx-ngx-cache/">配置 Nginx 作为缓存服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/OpenShift-Install/">OpenShift 3.9  部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/31/redis-master-slave-replication-deploy/">Redis 主从复制部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/31/redis-master-slave-replication/">Redis 主从复制原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/31/redis-RBD-AOF2/">Redis 持久化详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/31/redis-RBD-AOF/">Redis持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/31/redis-jianjie/">Redis简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/31/redis/">Redis部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Message-Queue/">大型网站架构之分布式消息队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/MongoDB/">MongoDB</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/NoSQL/">NoSQL 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/MySQL-Percona-XtraDB-Cluster/">部署Percona XtraDB Cluster</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/MySQL-ProxySQL/">基于Proxy SQL实现 MySQL主从复制的读写分离</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/MySQL-HA/">常见MySQL高可用解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/MySQL-MHA-1/">MHA工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/MySQL-replication-4/">MySQL 主从复制 SHOW SLAVE STATUS 参数详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/MySQL-replication-3/">MySQL 主主同步部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/MySQL-replication-2/">MySQL 主从复制部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/MySQL-replication-1/">MySQL 主从复制原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/Percona-XtraBackup/">Percona XtraBackup</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/Mysqldump/">一次完整的mysqldump备份和恢复操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/zookeeper/">Zookeeper 的功能以及工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/23/CAP/">CAP 定理的含义</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/31/Linux-Centos7-VNC/">CentOS 7 配置 VNC</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/30/Linux-question-1/">linux删除文件未释放空间问题处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/30/Linux-lsof/">lsof 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/26/Kubernetes-ContainerCreating/">Kubernetes创建容器状态一直为ContainerCreating问题排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/26/Kubernetes/">Kubernetes</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/25/KVM/">KVM</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/23/CDN/">CDN技术原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-container/">容器化思维</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-dockerfile-1/">Dockerfile 实践心得</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-monitor/">Docker容器的监控手段</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-dockerfile-use/">Dockerfile的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-network-3/">Docker高级网络实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-security/">Dcoekr与容器安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-network-2/">Docker 网络管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-volume-2/">Docker 数据卷</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-storage-manage/">Docker 存储管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-manage-image/">Docker 镜像管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-libcontainer/">libcontainer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-client-daemon/">docker client和daemon</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-arch/">Docker 架构概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-cgroups/">cgroups资源限制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-namespace/">namespace资源隔离</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-harbor/">使用vmware harbor构建镜像仓库</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-repertory/">Docker构建私有仓库</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-dockerfile/">Dockerfile编写</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-network/">Docker网络管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-volume/">Docker数据卷</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-commit-image/">通过commit方式制作Docker镜像</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-manage-1/">Docker镜像管理及容器管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/Docker-Install/">Docker安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/IaaS-PaaS-SaaS/">IaaS, PaaS, SaaS的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/09/Linux-iftop/">网络带宽监控工具 iftop</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/06/Linux-iotop/">磁盘io监控工具 iotop</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/05/Jenkins/">Jenkins</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/CI/">持续集成是什么?</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/03/document-style-guide/">中文技术文档的写作规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/03/ELK-Deploy/">ELK 6.3 部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/28/ELK/">开源日志实时分析平台ELK</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/26/Linux-opt-map/">Linux 运维技能树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/24/Ansible-CMDB/">Ansible CMDB</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/18/GlusterFS-Deploy/">GlusterFS 部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/18/GlusterFS/">GlusterFS 存储结构原理介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/16/Linux-top/">top 命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/10/Python-if/">Python基础 之 if语句</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/OpenvSwitch-Install/">安装Open vSwitch</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/Why-Use-OpenvSwitch/">为什么要用Open vSwitch？</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/OVS/">What Is Open vSwitch</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/Python-tuple/">Python常用数据类型-元组</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/Python-list2/">Python常用数据类型-列表2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/Python-for-range/">Python 之 for循环和range()函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/Jira/">Jira</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/06/Python-list/">Python常用数据类型-列表</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/06/Python-Notes/">Python 之 注释</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/06/Python-data-type-digital/">Python常用数据类型-数字</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/06/Python-data-type-string/">Python常用数据类型-字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/05/Python-variable/">Python变量</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/05/Python3-print/">Python3 print函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/05/OOP/">面向对象程序设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/05/Python/">Python简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/04/dokuwiki/">开源WIKI：DokuWIKI</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/04/telnet-lanjin-CMDB/">腾讯蓝鲸CMDB</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/26/ISA/">指令集架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/Docker-Jianjie/">Docker简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/Docker-Why-Use/">为什么要用Docker？</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/Docker-Xunnihua/">Xen、OpenVZ、KVM、Hyper-V、VMWare虚拟化技术介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/Zabbix-Jiankong-Nginx/">Zabbix：监控Nginx状态</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/Zabbix-Wechat-Baojing/">Zabbix：实现新版微信告警</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/Zabbix-Caozuo-Action/">Zabbix：操作Actions</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/Zabbix-Huandengpian/">Zabbix：幻灯片演示</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/Zabbix-Graph-Zidingyi/">Zabbix：自定义图形Graph</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/Zabbix-Graph-Jiandan/">Zabbix：简单图形Graph</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/Zabbix-Changyong-Peizhi/">Zabbix常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/Zabbix/">Zabbix</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/Zabbix-Open-Source-Tools/">开源监控工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Zabbix-Jiankong-MySQL/">Zabbix：监控MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Zabbix-User/">Zabbix：用户</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Zabbix-Macro/">Zabbix：宏macro</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Zabbix-Shijian-Tongzhi-Zidingyi/">Zabbix：事件通知 自定义警报提示</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Zabbix-Shijian-Tongzhi-Email/">Zabbix：事件通知 E-mail</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Zabbix-Shijian-Tongzhi/">Zabbix：事件通知</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Zabbix-Graph-Juhe/">Zabbix：聚合图形Graph</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Zabbix-Tuoputu/">Zabbix：拓扑图</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Zabbix-Graph/">Zabbix：图形Graph</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Zabbix-Action-Shoudong-Guanbi/">Zabbix：手动关闭事件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/Zabbix-Action/">Zabbix：事件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Tirigger-Yanzhongxin/">Zabbix：触发器trigger严重性</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Tirigger-Danweifuhao/">Zabbix：触发器trigger单位符号</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Tirigger-Dependencies/">Zabbix：触发器trigger依赖关系Dependencies</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Tirigger-Peizhi/">Zabbix：配置触发器trigger</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Item-Zidingyi-Keys/">Zabbix：监控项item中自定义key</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Item-All-Keys/">Zabbix：监控项item中所有agent key</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Item-Time-Jiange/">Zabbix：监控项item自定义间隔</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Item-Key/">Zabbix：监控项item的key</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Create-Item/">Zabbix：创建监控项items</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Piliang-Host/">Zabbix：批量更新主机信息</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Add-Host/">Zabbix：配置主机hosts和主机组</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Disk/">Zabbix系统所需磁盘空间计算公式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/23/Zabbix-Install/">安装Zabbix</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/MySQL-MariaDB-Install-Yum/">MarraiDB安装-yum方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/MySQL-MariaDB-Install-Binary/">MarraiDB安装-通用二进制方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/MySQL/">MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/MySQL-Liuxing-Database/">目前流行的开源RDBMS</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/MySQL-Guanxi-Database/">关系型数据概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/MySQL-Fanshi/">设计关系数据库的范式基础概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/MySQL-Data-Jiegou/">数据结构模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/MySQL-DataBase/">数据库简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/09/Memcached-Tomcat-Session-Manager/">tomcat + memcached session manager共享session</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/09/Memcached-Install-Changyong-Commands/">Memcached安装和常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/09/Memcached/">Memcached</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/08/Tomcat-Session-Jiqun/">搭建Tomcat会话集群</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/08/Tomcat-Httpd-session-Bangding-Tomcat/">实现httpd会话绑定</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/Tomcat-Httpd-ajp-Diaodu-Tomcat/">Httpd基于ajp协议调度Tomcat集群</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/Tomcat-Httpd-http-Diaodu-Tomcat/">Httpd基于http协议调度Tomcat集群</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/Tomcat-Nginx-Diaodu-Tomcat/">Nginx调度Tomcat集群</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/Tomcat-Keep-Session/">会话保持解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/Tomcat-Session/">HTTP会话原理解释与应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Varnish-Log/">Varnish日志</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Varnish-varnishadm-status/">varnishadm设定后台server状态</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Varnish-Fuzaijunhen-healthy/">实现后端server负载均衡+健康检测</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Varnish-Fuzaijunhen-Server/">实现后端server负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Varnish-Many-Server/">定义多个后端server</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Varnish-Qingli-Cache/">Varnish缓存清理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Varnish-varnishadm/">varnishadm(命令行接口)常用子命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Varnish-VCL/">vcl：缓存策略配置工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Varnish/">Varnish</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Varnish-Cache2/">Cache缓存相关二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Varnish-Cache/">Cache缓存相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Tomcat-solo/">部署solo应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Tomcat-Httpd-Proxy/">Httpd代理Tomcat</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Tomcat-Nginx-Proxy/">Nginx代理Tomcat</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Tomcat-Web/">Tomcat web管理界面</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Tomcat-configure/">Tomcat常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Tomcat-Install/">安装tomcat</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Haproxy-Https/">HAProxy支持https协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Haproxy-TCP-Proxy/">HAProxy四层TCP代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Haproxy-configure-ACL/">HAPoxy-ACL</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Haproxy-configure/">Haproxy常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Haproxy-Diaodu-Suanfa/">HAProxy调度算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Haproxy-Log/">HAProxy log日志设置</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Haproxy-Configuration-File/">HAProxy配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Haproxy/">Haproxy简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/Ansible-configure2/">Ansible常用模块二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/Ansible-configure1/">Ansible常用模块一</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/Ansible-Install/">Ansible安装与使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/Expect-Copy-Ssh-Key/">脚本实例四：批量拷贝SSH密钥</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/KeepAlived-Danzhu-Nginx/">实现Nginx+KeepAlived单主模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/KeepAlived-Log/">KeepAlived单独记录日志</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/KeepAlived-Shuangzhu-LVS/">实现LVS+KeepAlived双主模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/KeepAlived-Danzhu-LVS/">实现LVS+KeepAlived单主模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/KeepAlived-Danzhu/">实现KeepAlived单主模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/KeepAlived-Configuration-File/">Keepalived配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/KeepAlived/">Keepalived简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/28/Nginx-ngx-stream-core-module/">模块  ngx_stream_core_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/28/Nginx-make2/">Nginx编译安装模块（非重装）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/28/Nginx-make/">Nginx编译安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/27/Nginx-ngx-http-upstream-module/">模块  ngx_http_upstream_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/27/Nginx-LNAMP/">LNAMP搭建WordPress</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/27/Nginx-ngx-http-fastcgi-module/">模块 ngx_http_fastcgi_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/27/Nginx-ngx-http-headers-module/">模块 ngx_http_headers_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/27/Nginx-ngx-http-proxy-module/">模块 ngx_http_proxy_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/27/Nginx-ngx-http-rewrite-module/">模块 ngx_http_rewrite_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/27/Nginx-ngx-http-referer-module/">模块 ngx_http_referer_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/26/Nginx-ngx-http-ssl-module/">模块 ngx_http_ssl_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/26/Nginx-ngx-http-gzip-module/">模块 ngx_http_gzip_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/26/Nginx-ngx-http-stub-status-module/">模块ngx_http_stub_status_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/26/Nginx-ngx-http-log-module/">模块 ngx_http_log_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/25/Nginx-http-auth-basic-module/">模块 ngx_http_auth_basic_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/25/Nginx-http-access-module/">模块 ngx_http_access_module</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/25/Nginx-configure2/">Nginx配置文件2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/25/Nginx-configure/">Nginx配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/21/Linux-LVS-suanfa/">LVS调度算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/21/Linux-LVS/">LVS负载均衡技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/21/Linux-iptables-SNAT/">SNAT与DNAT</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/16/FTP-SSL/">实现基于SSL的FTPS</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/16/FTP-config/">Vsftp常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/09/Httpd-https/">httpd-2.2 实现https</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/11/Dropbear/">Dropbear-轻量级SSH服务器和客户端</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/AIDE/">AIDE</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/SSH-mianmi/">SSH命令与ssh免密登陆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/Openssl/">Openssl证书请求和自签名</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/01/Linux-IP-Address/">IP地址</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/28/JiHuaRenWu-AT/">at命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/Linux-shell-script1/">脚本实例一：创建脚本的脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/20/Linux-Shell-bianliang/">Shell 变量简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/02/Linux-Disk-jiegou/">硬盘结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/Linux-Disk/">硬盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/23/User-Administration/">用户组管理相关命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/IO-chongdingxiang/">输入输出重定向</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/07/Linux-Shell/">Linux Shell</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/06/Linux-GUI-CLI/">GUI和CLI</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/05/Linux-Terminal/">终端 Terminal</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/04/Linux-Centos6-9-Install/">Centos6.9 安装详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/03/Linux-User-space/">用户空间和内核空间</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/03/Linux-time/">Linux 发行版时间线</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/02/Linux-open-source/">常见开源协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/02/Linux-history/">Linux 历史?</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/01/Linux/">什么Linux？</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/01/Linux-fengnuoyiman/">冯.诺依曼体系结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/01/Linux-ABI-API/">ABI和API</a></li></ul>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 Peter
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
    </body>
</html>
