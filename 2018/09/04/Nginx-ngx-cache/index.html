<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Peter's technology stack."><title>配置 Nginx 作为缓存服务 | Peter's technology stack.</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Nginx/">Nginx</a></div><div class="post-time">2018-09-04</div></div></div><div class="container post-header"><h1>配置 Nginx 作为缓存服务</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置示例及说明"><span class="toc-number">1.</span> <span class="toc-text">配置示例及说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http配置说明"><span class="toc-number">1.1.</span> <span class="toc-text">http配置说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#location配置说明"><span class="toc-number">1.2.</span> <span class="toc-text">location配置说明</span></a></li></ol></li></ol></details></div><div class="container post-content"><h3 id="配置示例及说明"><a href="#配置示例及说明" class="headerlink" title="配置示例及说明"></a>配置示例及说明</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    proxy_buffering on;</span><br><span class="line">    proxy_buffer_size 8k;</span><br><span class="line">    proxy_buffers 8 8K;</span><br><span class="line">    proxy_busy_buffers_size 16k;</span><br><span class="line">    proxy_connect_timeout 60s;</span><br><span class="line">    proxy_read_timeout 60s;</span><br><span class="line">    proxy_send_timeout 60s;</span><br><span class="line"></span><br><span class="line">    proxy_cache_path /data/nginx/cache keys_zone=nginx_cache:10240m loader_threshold=300 loader_files=200  levels=1:2 inactive=5m max_size=50g;</span><br><span class="line">    upstream web &#123;</span><br><span class="line">        server 10.6.168.20:80 weight=1 ;</span><br><span class="line">        server 10.6.168.20:80 weight=1 ;</span><br><span class="line">        ip_hash ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        server_name  www.zeforce.com;</span><br><span class="line">        root         /data/www;</span><br><span class="line">#       set $upstream http://10.6.168.20:80 ;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_cache nginx_cache;</span><br><span class="line">            proxy_pass  http://web;</span><br><span class="line">            #proxy_cache_key $uri;</span><br><span class="line">            #proxy_cache_purge $purge_method;</span><br><span class="line">            add_header cache-status $upstream_cache_status; # 增加http报头，例如；命中：cache-status: HIT，未命中：cache-status: MISS</span><br><span class="line">            proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;</span><br><span class="line">            proxy_cache_methods GET HEAD POST;</span><br><span class="line">            proxy_cache_use_stale error  timeout  invalid_header  updating  http_500  http_502  http_503  http_504  http_403  http_404;</span><br><span class="line">            proxy_cache_revalidate on ;</span><br><span class="line">            proxy_cache_lock on ;</span><br><span class="line">            proxy_cache_valid 200 302 10m;</span><br><span class="line">            proxy_cache_valid 301      1h;</span><br><span class="line">            proxy_cache_valid any      1m;</span><br><span class="line">            proxy_cache_background_update on ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="http配置说明"><a href="#http配置说明" class="headerlink" title="http配置说明"></a>http配置说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">proxy_buffering on;     # 启用来自代理服务器的响应缓冲。启用缓冲后，nginx会尽快从代理服务器接收响应，并将其保存到由proxy_buffer_size和proxy_buffers指令设置的缓冲区中 。</span><br><span class="line"></span><br><span class="line">proxy_buffer_size 8k;   # 设置size用于读取从代理服务器接收到的响应的第一部分的缓冲区。这部分通常包含一个小的响应头。默认情况下，缓冲区大小等于一个内存页面。这是4K或8K，取决于平台。但是，它可以做得更小。</span><br><span class="line"></span><br><span class="line">proxy_buffers 8 8K;     # 设置number和size用于读取从所述代理服务器的响应，供用于单个连接的缓冲器。默认情况下，缓冲区大小等于一个内存页面。这是4K或8K，取决于平台。</span><br><span class="line"></span><br><span class="line">proxy_busy_buffers_size 16k;    # 当启用对代理服务器的响应缓冲时，限制size可能正忙于向客户端发送响应的缓冲区总数，而响应尚未完全读取。同时，其余的缓冲区可以用于读取响应，并且如果需要的话，缓冲部分对临时文件的响应。默认情况下，size受到proxy_buffer_size和proxy_buffers指令设置的两个缓冲区的大小的限制 。</span><br><span class="line"></span><br><span class="line">proxy_connect_timeout 60s;      # 定义与代理服务器建立连接的超时时间。应该指出的是，这个超时通常不能超过75秒。</span><br><span class="line"></span><br><span class="line">proxy_read_timeout 60s;         # 定义从代理服务器读取响应的超时时间。超时只在两次连续的读操作之间设置，而不是用于传输整个响应。如果代理服务器在此时间内没有传输任何内容，则连接将关闭。</span><br><span class="line"></span><br><span class="line">proxy_send_timeout 60s;         # 设置向代理服务器发送请求的超时时间。超时只在两次连续写入操作之间设置，而不是用于传输整个请求。如果代理服务器在此时间内没有收到任何内容，则连接将关闭。</span><br><span class="line"></span><br><span class="line">proxy_cache_path /data/nginx/cache keys_zone=nginx_cache:10240m loader_threshold=300 loader_files=200  levels=1:2 inactive=5m max_size=50g;     # 设置缓存的路径和其他参数。缓存数据存储在文件中。缓存中的文件名是将MD5函数应用于 缓存键的结果。</span><br><span class="line"># /data/nginx/cache 定义缓存文件存放的位置</span><br><span class="line"># keys_zone=nginx_cache:10240m  指定缓存名称和占用内存空间的大小</span><br><span class="line"># loader_threshold=300  指定每次加载执行的时间</span><br><span class="line"># loader_files=200      每次最多加载的数量</span><br><span class="line"># max_size=50g          缓存硬盘空间最多为50g</span><br><span class="line"># levels=1:2            表示创建两级目录结构，缓存目录的第一级目录是1个字符，第二级目录是2个字符，比如/export/cache/proxy_cache/7/3c/，如果将所有文件放在一级目录下的话，文件量很大，会导致文件访问慢。</span><br><span class="line"># inactive=5m       inactive指定被缓存的内容多久不被访问将从缓存中移除，以保证内容的新鲜，默认为10分钟</span><br></pre></td></tr></table></figure>
<h4 id="location配置说明"><a href="#location配置说明" class="headerlink" title="location配置说明"></a>location配置说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache nginx_cache;        # 指定使用哪个共享内存区存储缓存信息</span><br><span class="line"></span><br><span class="line">proxy_pass  http://web;         # 指定代理向后端的服务器</span><br><span class="line"></span><br><span class="line">add_header cache-status $upstream_cache_status; # 增加http报头，　　HIT：缓存命中，直接返回缓存中内容，不回源到后端。</span><br><span class="line"># MISS：缓存未命中，回源到后端获取最新的内容。</span><br><span class="line"># EXPIRED：缓存命中但过期了，回源到后端获取最新的内容。</span><br><span class="line"># UPDATING：缓存已过期但正在被别的Nginx Worker进程更新，配置了proxy_cache_use_stale updating指令时会存在该状态。</span><br><span class="line"># STALE：缓存已过期，但因后端服务出现了问题（比如后端服务挂了）返回过期的响应，配置了如proxy_cache_use_stale error timeout指令后会出现该状态。</span><br><span class="line"># REVALIDATED：启用proxy_cache_revalidate指令后，当缓存内容过期时，Nginx通过一次if-modified-since的请求头去验证缓存内容是否过期，此时会返回该状态。</span><br><span class="line"># BYPASS：proxy_cache_bypass指令有效时，强制回源到后端获取内容，即使已经缓存了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;    # 类似于proxy_no_cache，但是，其控制什么情况不使用缓存的内容，而是直接到后端获取最新的内容。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">proxy_cache_methods GET HEAD POST;      # 如果此指令中列出了客户端请求方法，那么响应将被缓存。“ GET”和“ HEAD”方法总是添加到列表中，但建议您明确指定它们。</span><br><span class="line"></span><br><span class="line">proxy_cache_use_stale error  timeout  invalid_header  updating  http_500  http_502  http_503  http_504  http_403  http_404;</span><br><span class="line"># 确定在与代理服务器通信期间可以使用过时的缓存响应。该指令的参数与proxy_next_upstream指令的参数相匹配 。</span><br><span class="line"># error如果无法选择代理服务器处理请求， 该参数还允许使用陈旧的缓存响应。</span><br><span class="line"># 此外，如果updating参数当前正在更新，则该参数允许使用陈旧的缓存响应。这允许在更新缓存数据时最大限度地减少对代理服务器的访问次数。</span><br><span class="line"># 使用陈旧的缓存响应也可以在响应变为陈旧（1.11.10）后的指定秒数内直接在响应头中启用。这比使用指令参数的优先级低。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">proxy_cache_revalidate on ;     # 使用带有“If-Modified-Since”和“If-None-Match”标头字段的条件请求启用对过期缓存项目的重新验证。</span><br><span class="line"># 当缓存过期后，如果开启了proxy_cache_revalidate，则会发出一次if-modified-since或if-none-match条件请求，如果后端返回304，则此时$upstream_cache_status为REVALIDATED，我们将得到两个好处，节省带宽和减少写磁盘的次数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">proxy_cache_lock on ;       # 当多个客户端同时请求同一份内容时，如果开启proxy_cache_lock（默认off），则只有一个请求被发送至后端。其他请求将等待该请求的返回。当第一个请求返回后，其他相同请求将从缓存中获取内容返回。当第一个请求超过了proxy_cache_lock_timeout超时时间（默认为5s），则其他请求将同时请求到后端来获取响应，且响应不会被缓存（在1.7.8版本之前是被缓存的）。启用proxy_cache_lock可以应对Dog-pile effect（当某个缓存失效时，同时有大量相同的请求没命中缓存，而同时请求到后端，从而导致后端压力太大，此时限制一个请求去拿即可）。</span><br><span class="line"></span><br><span class="line">proxy_cache_valid 200 302 10m;      # 为不同的响应状态码设置缓存时间。如果是proxy_cache_valid5s，则200、301、302响应都将被缓存。</span><br><span class="line"></span><br><span class="line">proxy_cache_valid 301      1h;      # 301 缓存时间为1h</span><br><span class="line"></span><br><span class="line">proxy_cache_valid any      1m;      #  所有缓存为1m</span><br><span class="line"></span><br><span class="line">proxy_cache_background_update on    # 允许启动后台子请求来更新国企的缓存项目，而过时的缓存响应则返回给客户端。请注意：有必要在更新时允许使用陈旧的缓存响应。</span><br></pre></td></tr></table></figure>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>