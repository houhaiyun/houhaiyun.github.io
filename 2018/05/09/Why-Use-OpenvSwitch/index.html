<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Peter's technology stack."><title>为什么要用Open vSwitch？ | Peter's technology stack.</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/SDN/">SDN</a></div><div class="post-time">2018-05-09</div></div></div><div class="container post-header"><h1>为什么要用Open vSwitch？</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要用Open-vSwitch？"><span class="toc-number">1.</span> <span class="toc-text">为什么要用Open vSwitch？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#The-mobility-of-state"><span class="toc-number">1.1.</span> <span class="toc-text">The mobility of state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Responding-to-network-dynamics"><span class="toc-number">1.2.</span> <span class="toc-text">Responding to network dynamics</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Maintenance-of-logical-tags"><span class="toc-number">1.3.</span> <span class="toc-text">Maintenance of logical tags</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hardware-integration"><span class="toc-number">1.4.</span> <span class="toc-text">Hardware integration</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol></details></div><div class="container post-content"><h3 id="为什么要用Open-vSwitch？"><a href="#为什么要用Open-vSwitch？" class="headerlink" title="为什么要用Open vSwitch？"></a>为什么要用Open vSwitch？</h3><p>虚拟机管理程序需要能够跨越虚拟机和外部世界之间的流量。在基于Linux的管理程序中，这常常意味着使用内置的L2交换机（Linux网桥），该交换机快速可靠。因此，有必要问为什么使用Open vSwitch。</p>
<p><strong>答案</strong>是Open vSwitch面向多服务器虚拟化部署，这是前一个堆栈不太适合的一个环境。这些环境通常以高度动态的端点，逻辑抽象的维护以及（有时）与专用交换硬件的集成或卸载为特征。</p>
<p>以下特征和设计注意事项有助于Open vSwitch应对上述要求。</p>
<a id="more"></a>
<h4 id="The-mobility-of-state"><a href="#The-mobility-of-state" class="headerlink" title="The mobility of state"></a>The mobility of state</h4><p>与网络实体（如虚拟机）关联的所有网络状态都应该易于在不同主机之间进行识别和迁移。这可以包括传统的“软状态”（例如L2学习表中的条目），L3转发状态，策略路由状态，ACL，QoS策略，监控配置（例如NetFlow，IPFIX，sFlow）等。</p>
<p>Open vSwitch支持在实例之间配置和迁移缓慢（配置）和快速网络状态。例如，如果VM在终端主机之间迁移，则不仅可以迁移相关配置（SPAN规则，ACL，QoS），而且还可以迁移任何实时网络状态（包括可能难以重建的现有状态）。此外，打开vSwitch状态是由一个真实的数据模型打印和支持的，允许开发结构化自动化系统。</p>
<h4 id="Responding-to-network-dynamics"><a href="#Responding-to-network-dynamics" class="headerlink" title="Responding to network dynamics"></a>Responding to network dynamics</h4><p>虚拟环境通常具有高速变化的特点。来来往往的虚拟机，及时向前和向后移动的虚拟机，逻辑网络环境的变化等等。</p>
<p>Open vSwitch支持许多功能，允许网络控制系统在环境发生变化时作出响应和调整。这包括简单的会计和可视性支持，如NetFlow，IPFIX和sFlow。但也许更有用，Open vSwitch支持支持远程触发器的网络状态数据库（OVSDB）。因此，一个编排软件可以“监视”网络的各个方面，并在其发生变化时作出响应。例如，这在今天被大量使用来响应和跟踪VM迁移。</p>
<p>Open vSwitch还支持OpenFlow作为导出远程访问以控制流量的方法。通过检查发现或链路状态的流量（例如LLDP，CDP，OSPF等），这有很多用途，包括全局网络发现。</p>
<h4 id="Maintenance-of-logical-tags"><a href="#Maintenance-of-logical-tags" class="headerlink" title="Maintenance of logical tags"></a>Maintenance of logical tags</h4><p>分布式虚拟交换机（例如VMware vDS和Cisco Nexus 1000V）通常通过附加或操纵网络数据包中的标签来维护网络内的逻辑上下文。这可以用来唯一标识虚拟机（以抵制硬件欺骗的方式），或者用于保存仅与逻辑域相关的其他上下文。构建分布式虚拟交换机的大部分问题都是为了高效并正确地管理这些标签。</p>
<p>Open vSwitch包含多种用于指定和维护标记规则的方法，所有这些方法都可供远程进程访问以供编排。此外，在许多情况下，这些标记规则以优化形式存储，因此它们不必与重量级网络设备耦合。例如，这允许配置，更改和迁移数千个标记或地址重新映射规则。</p>
<p>同样，Open vSwitch支持GRE实现，可以处理数千个并发GRE隧道，并支持远程配置隧道创建，配置和拆除。例如，这可以用于连接不同数据中心中的私有VM网络。</p>
<h4 id="Hardware-integration"><a href="#Hardware-integration" class="headerlink" title="Hardware integration"></a>Hardware integration</h4><p>Open vSwitch的转发路径（内核数据路径）旨在将分组处理“卸载”到硬件芯片组，无论是安装在经典的硬件交换机机箱还是位于终端主机NIC中。这允许Open vSwitch控制路径能够控制纯粹的软件实现或硬件开关。</p>
<p>目前有许多努力将Open vSwitch移植到硬件芯片组上。这些包括多个商家硅芯片组（Broadcom和Marvell）以及许多供应商特定的平台。</p>
<p>硬件集成的优势不仅在于虚拟化环境中的性能。如果物理交换机也暴露Open vSwitch控制抽象，则可以使用相同的机制来管理裸机和虚拟化主机环境，以实现自动网络控制。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在许多方面，Open vSwitch在设计空间中的目标位置与以前的虚拟机管理程序网络堆栈不同，主要关注在基于Linux的大型虚拟化环境中对自动化和动态网络控制的需求。</p>
<p>Open vSwitch的目标是保持内核代码尽可能小（如性能所需），并在适用时重用现有子系统（例如Open vSwitch使用现有的QoS堆栈）。从Linux 3.3开始，Open vSwitch作为内核的一部分包含在内，用户空间实用程序的打包在大多数流行的发行版上都可用。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>