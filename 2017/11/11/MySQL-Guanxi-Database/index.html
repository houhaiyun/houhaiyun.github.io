<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Peter's technology stack."><title>关系型数据概念 | Peter's technology stack.</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/数据库基础/">数据库基础</a></div><div class="post-time">2017-11-11</div></div></div><div class="container post-header"><h1>关系型数据概念</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDBMS（关系型数据库管理系统）术语"><span class="toc-number">1.</span> <span class="toc-text">RDBMS（关系型数据库管理系统）术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关系型数据库"><span class="toc-number">2.</span> <span class="toc-text">关系型数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关系型数据库特点"><span class="toc-number">2.1.</span> <span class="toc-text">关系型数据库特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关系操作"><span class="toc-number">2.2.</span> <span class="toc-text">关系操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL"><span class="toc-number">2.3.</span> <span class="toc-text">SQL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隔离级别"><span class="toc-number">3.</span> <span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC"><span class="toc-number">4.</span> <span class="toc-text">MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#致谢"><span class="toc-number">5.</span> <span class="toc-text">致谢</span></a></li></ol></details></div><div class="container post-content"><h3 id="RDBMS（关系型数据库管理系统）术语"><a href="#RDBMS（关系型数据库管理系统）术语" class="headerlink" title="RDBMS（关系型数据库管理系统）术语"></a>RDBMS（关系型数据库管理系统）术语</h3><ul>
<li><code>Database</code>：数据库是一个表的集合，与相关的数据。 </li>
<li><code>Table</code>： 一个表的数据是一个矩阵。在一个数据库中的表看起来像一个简单的电子表格。 </li>
<li><code>Column</code>： 一列（数据元素）包含的是同一个样的数据，例如列邮政编码。 </li>
<li><code>Row</code>： 行（元组，进入或记录）是一组相关的数据，例如一个订阅的数据。 </li>
<li><code>Redundancy</code>： 存储数据的两倍，冗余，使系统速度更快。 </li>
<li><code>Primary Key</code>：  主键是唯一的。一个关键值可以在一个表中不能出现两次。使用<code>key</code>我们可以在大多数行找到。 </li>
<li><code>Foreign Key</code>： 外键是两个表之间的链接杆。 </li>
<li><code>Compound Key</code>： 复合键（组合键）是一个重要的，由多个列，一列是因为并非十分独特。 </li>
<li><code>Index</code>：在一个数据库中的索引类似于在一本书的背面的一个索引。 </li>
<li><code>Referential Integrity</code>：参照完整性可以确保一个外键的值总是指向一个现有的行。</li>
</ul>
<a id="more"></a>
<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ol>
<li><p>关系型数据库可以简单的理解为二维数据库，表格式类似于<code>excel</code>表格，我们平时我接触的数据据，一般都是关系型数据库。</p>
</li>
<li><p>关系型数据库不是唯一的高级数据库模型，也不是最优的一种，但是，关系型数据库是现今使用最广泛、最易于理解和使用的数据库模型。</p>
</li>
</ol>
<ul>
<li>关系：可以理解成一张二维表，每个关系都有一个关系名，即表名。</li>
<li>元组：可以理解成二维表中的一行，在数据库中常被称作记录。 </li>
<li>属性：可以理解成二维表中的一列，在数据库中常被成为字段。 </li>
<li>域：属性的取值范围，也是数据库中某一列的取值限制。 </li>
<li>关键字：一组可以唯一标识元组的属性。数据库中常称为主键有一个或多个列组成。 </li>
<li>关系模式：对关系的描述，在数据库中通常称之为表结构。 </li>
</ul>
<h4 id="关系型数据库特点"><a href="#关系型数据库特点" class="headerlink" title="关系型数据库特点"></a>关系型数据库特点</h4><ul>
<li><strong>容易理解</strong>：二维表结构是非常贴近逻辑世界的一个概念，相对与网状、层次以及其它模型更容易理解。</li>
<li><strong>使用方便</strong>：通过SQL语言程序员和数据管理员可以很方便的在逻辑层面操作数据库而不必理解其底层实现。</li>
<li><strong>易于维护</strong>：丰富的完整性（实体完整性、参照完整性、用户自定义完整性）降低数据冗余和数据不一致的概率。    </li>
</ul>
<h4 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h4><ul>
<li>数据查询：选择、投影、连接、并、交、差、除</li>
<li>数据操作：增加、删除、修改、查询</li>
</ul>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p><code>SQL</code>(<code>Structured Query Language</code>)：结构化查询语言，一种特殊目的的编程语言，数据库查询和程序设计语言，用于存储数据以及查询、更新和管理关系型数据库。</p>
<p><strong>SQL查询语言组成部分</strong></p>
<ul>
<li><code>DDL</code>(<code>Data Definition Languages</code>)语句：数据定义语句，用于定义不同的数据段、数据库、表、列、索引等数据库的对象定义。常用关键字主要包括<code>create</code>、<code>drop</code>、<code>alter</code>等。</li>
<li><code>DML</code>(<code>Data Manipulation Language</code>)语句：数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性。常用关键字包括<code>insert</code>、<code>delete</code>、<code>update</code>和<code>select</code>等。</li>
<li><code>DCL</code>(<code>Data Control Language</code>)语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句，用于定义数据库、表、字段、用户的访问权限和安全级别。常用关键字有<code>grant</code>、<code>revoke</code>等。</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p><code>SQL</code>标准定义了4类隔离级，包括了一些具体规则，用来限定事务内外的哪些改变时可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p>
<ul>
<li><code>READ UNCOMMITTED</code>(读取未提交内容) <ul>
<li>在<code>READ UNCOMMITTED</code>隔离级，所有事务都可以“看到”未提交事务的执行结果。在这种级别上，可能会产生很多问题。本隔离级很少用于实际应用，因为它的性能也不比其他级别好多少，而别的级别还有其他更多的优点。读取未提交数据，也被称之为<code>“脏读(Dirty Read)”</code></li>
</ul>
</li>
<li><code>READ COMMITTED</code>(读取提交内容) <ul>
<li>大多数数据库系统的默认隔离级是<code>READ COMMITTED</code>(但这不是<code>MYSQL</code>默认的)。它满足了隔离的早先简单定义：一个事务在开始时，只能“看见”已经提交事务所做的改变，一个事务从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交。这种隔离级别也支持所谓的“不可重复读(<code>Nonrepeatable Read</code>)”。这意味着用户运行同一语句两次，看到的结果是不同的。</li>
</ul>
</li>
<li><code>REPEATABLE READ</code>(可重读) <ul>
<li><code>REPEATABLE READ</code> 隔离级解决了<code>READ UNCOMMITTED</code>隔离级导致的问题。它确保同一事务的多个实例在并发读取数据时，会“看到相同的”数据行。不过理论上，这会导致另一个棘手问题：幻读(<code>Phantom Read</code>)。简单来说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”行。<code>InnoDB</code>和<code>Falcon</code>存储引擎通过多版本并发控制机制解决了幻读问题。 <code>REPEATABLE READ</code> 是<code>MYSQL</code>的默认事务隔离级。<code>InnoDB</code>和<code>Falcon</code>存储引擎都遵循这种设置。</li>
</ul>
</li>
<li><code>SERIALIZABLE</code>(可串行化) <ul>
<li><code>SERIALIZABLE</code>是最高级别的隔离级，它通过强制事务排斥，使之不可能相互冲突，从而解决幻读问题。简言之，<code>SERIALIZABLE</code>是在每个读的数据行上加锁。在这个级别，可能导致大量的超时现象和锁竞争现象。很少看到有用户选择这种隔离级。</li>
</ul>
</li>
</ul>
<p><strong>注</strong> ：不可重复读与幻读：不可重复读的重点是修改(同样的查询条件，你读取过的数据，再次读取出来发现值不一样了);幻读的重点在于新增或者删除(同样的查询条件，第1次和第2次读出来的记录数不一样)</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>就是使用时间戳或者事务<code>ID</code>来控制数据的多版本</p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="http://cuchadanfan.blog.51cto.com/9940284/1688364" target="_blank" rel="noopener">粗茶淡饭：MySQL（一）之通用二进制格式安装MySQL及数据库基本概念</a></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>