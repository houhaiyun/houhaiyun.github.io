<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>LVS调度算法</title>
      <link href="/2017/10/21/Linux-LVS-suanfa-2017-10-21/"/>
      <url>/2017/10/21/Linux-LVS-suanfa-2017-10-21/</url>
      <content type="html"><![CDATA[<h3 id="LVS的调度算法分为静态与动态两类："><a href="#LVS的调度算法分为静态与动态两类：" class="headerlink" title="LVS的调度算法分为静态与动态两类："></a>LVS的调度算法分为静态与动态两类：</h3><center><img src="http://ovuhiuqqd.bkt.clouddn.com/lvs.jpg"></center><a id="more"></a><h4 id="1-静态算法（4种）：只根据算法进行调度-而不考虑后端服务器的实际连接情况和负载情况"><a href="#1-静态算法（4种）：只根据算法进行调度-而不考虑后端服务器的实际连接情况和负载情况" class="headerlink" title="1.静态算法（4种）：只根据算法进行调度 而不考虑后端服务器的实际连接情况和负载情况"></a>1.静态算法（4种）：只根据算法进行调度 而不考虑后端服务器的实际连接情况和负载情况</h4><blockquote><p>①.RR：轮叫调度（Round Robin）<br>　 调度器通过”轮叫”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载｡</p><p>②.WRR：加权轮叫（Weight RR）<br>　 调度器通过“加权轮叫”调度算法根据真实服务器的不同处理能力来调度访问请求。这样可以保证处理能力强的服务器处理更多的访问流量。调度器可以自动问询真实服务器的负载情况,并动态地调整其权值。</p><p>③.DH：目标地址散列调度（Destination Hash ）<br>　 根据请求的目标IP地址，作为散列键(HashKey)从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p><p>④.SH：源地址 hash（Source Hash）<br>　 源地址散列”调度算法根据请求的源IP地址，作为散列键(HashKey)从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空｡</p></blockquote><h4 id="2-动态算法（6种）：前端的调度器会根据后端真实服务器的实际连接情况来分配请求"><a href="#2-动态算法（6种）：前端的调度器会根据后端真实服务器的实际连接情况来分配请求" class="headerlink" title="2.动态算法（6种）：前端的调度器会根据后端真实服务器的实际连接情况来分配请求"></a>2.动态算法（6种）：前端的调度器会根据后端真实服务器的实际连接情况来分配请求</h4><blockquote><p>①.LC：最少链接（Least Connections）<br>　 调度器通过”最少连接”调度算法动态地将网络请求调度到已建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用”最小连接”调度算法可以较好地均衡负载。</p><p>②.WLC：加权最少连接(默认采用的就是这种)（Weighted Least Connections）<br>　 在集群系统中的服务器性能差异较大的情况下，调度器采用“加权最少链接”调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载｡调度器可以自动问询真实服务器的负载情况,并动态地调整其权值。</p><p>③.SED：最短延迟调度（Shortest Expected Delay ）<br>　 在WLC基础上改进，Overhead = （ACTIVE+1）*256/加权，不再考虑非活动状态，把当前处于活动状态的数目+1来实现，数目最小的，接受下次请求，+1的目的是为了考虑加权的时候，非活动连接过多缺陷：当权限过大的时候，会倒置空闲服务器一直处于无连接状态。</p><p>④.NQ永不排队/最少队列调度（Never Queue Scheduling NQ）<br>　 无需队列。如果有台 realserver的连接数＝0就直接分配过去，不需要再进行sed运算，保证不会有一个主机很空间。在SED基础上无论+几，第二次一定给下一个，保证不会有一个主机不会很空闲着，不考虑非活动连接，才用NQ，SED要考虑活动状态连接，对于DNS的UDP不需要考虑非活动连接，而httpd的处于保持状态的服务就需要考虑非活动连接给服务器的压力。</p><p>⑤.LBLC：基于局部性的最少链接（locality-Based Least Connections）<br>　 基于局部性的最少链接”调度算法是针对目标IP地址的负载均衡，目前主要用于Cache集群系统｡该算法根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器;若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用“最少链接”的原则选出一个可用的服务器，将请求发送到该服务器｡</p><p>⑥. LBLCR：带复制的基于局部性最少连接（Locality-Based Least Connections with Replication）<br>　 带复制的基于局部性最少链接”调度算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统｡它与LBLC算法的不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射｡该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按”最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按“最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器｡同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</p></blockquote><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="http://www.178linux.com/13570" target="_blank" rel="noopener">本文来自：Linux运维部落-LVS原理详解</a></p>]]></content>
      
      
        <tags>
            
            <tag> LVS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LVS负载均衡技术</title>
      <link href="/2017/10/21/Linux-LVS-2017-10-21/"/>
      <url>/2017/10/21/Linux-LVS-2017-10-21/</url>
      <content type="html"><![CDATA[<h3 id="LVS-集群的通用结构"><a href="#LVS-集群的通用结构" class="headerlink" title="LVS 集群的通用结构"></a>LVS 集群的通用结构</h3><p><code>LVS</code>集群采用 <code>IP</code> 负载均衡技术，属于 <code>IP</code> 层的交换（<code>L4</code>） , 具有很好的吞吐率。调度器分析客户端到服务器的 <code>IP</code> 报头信息， 将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器， <code>LVS</code> 集群系统的通用结构如图所示， 主要包含四大部分：</p><a id="more"></a><center><img src="http://ovuhiuqqd.bkt.clouddn.com/LVS-%E7%BB%93%E6%9E%84.jpg"></center><p><strong>负载调度器</strong>（<code>load balancer</code>），它是整个集群对外面的前端机，负责将客户的请求发送到一组服务器上执行，而客户认为服务是来自一个 <code>IP</code> 地址上的。当客户请求到达时，调度器只根据负载情况从服务器池中选出一个服务器，将该请求转发到选出的服务器，并记录这个调度；当这个请求的其他报文到达，也会被转发到前面选出的服务器。因为所有的操作都是在操作系统核心空间中将完成的，它的调度开销很小，所以具有很高的吞吐率</p><p><strong>服务器池</strong>（<code>server pool</code>），是一组真正执行客户请求的服务器，执行的任务有<code>WEB</code>、 <code>MAIL</code>、 <code>FTP</code> 和 <code>DNS</code> 等。服务器池的结点数目是可变的， 当整个系统收到的负载超过目前所有结点的处理能力时，可以在服务器池中增加服务器来满足不断增长的请求负载。对大多数网络服务来说，结点与结点间不存在很强的相关性，所以整个系统的性能可以随着服务器池的结点数目增加而线性增长</p><p><strong>后端存储</strong>（<code>backend storage</code>），它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。</p><p><strong><code>Graphic Monitor</code></strong> 是为系统管理员提供整个集群系统的监视器，它可以监视系统中每个结点的状况。</p><h3 id="IP-负载均衡技术"><a href="#IP-负载均衡技术" class="headerlink" title="IP 负载均衡技术"></a>IP 负载均衡技术</h3><p>在已有的 <code>IP</code> 负载均衡技术中有三种（据说还有第四种<code>lvs-fullnat</code>，本文中不会涉及），一是通过网络地址转换实现虚拟服务器的 <code>VS/NAT</code> 技术（<code>Virtual Server via Network Address Translation</code>）， 二是通过直接路由的 <code>VS/DR</code> 技术（<code>Virtual Server via Direct Routing</code>），三是通过 <code>IP</code> 隧道实现虚拟服务器的 <code>VS/TUN</code> 技术（<code>Virtual Server via IP Tunneling</code>）。</p><h3 id="通过NAT实现虚拟服务器（VS-NAT）"><a href="#通过NAT实现虚拟服务器（VS-NAT）" class="headerlink" title="通过NAT实现虚拟服务器（VS/NAT）"></a>通过NAT实现虚拟服务器（VS/NAT）</h3><p><code>VS/NAT</code> 的体系结构如下图所示， 在一组服务器前有一个调度器，它们是通过 Switch 相连接的。这些服务器提供相同的网络服务、相同的内容，即不管请求被发送到哪一台服务器，执行结果是一样的。</p><center><img src="http://ovuhiuqqd.bkt.clouddn.com/LVS-NAT.jpg"></center><h4 id="通过如下的VS-NAT配置为例，来了解报文的结构："><a href="#通过如下的VS-NAT配置为例，来了解报文的结构：" class="headerlink" title="通过如下的VS/NAT配置为例，来了解报文的结构："></a>通过如下的VS/NAT配置为例，来了解报文的结构：</h4><center><img src="http://ovuhiuqqd.bkt.clouddn.com/VS-NAT.jpg"></center><h3 id="通过直接路由实现虚拟服务器（VS-DR）"><a href="#通过直接路由实现虚拟服务器（VS-DR）" class="headerlink" title="通过直接路由实现虚拟服务器（VS/DR）"></a>通过直接路由实现虚拟服务器（VS/DR）</h3><p>在 <code>VS/NAT</code> 的集群系统中，请求和响应的数据报文都需要通过负载调度器，当真实服务器的数目在 10 台和 20 台之间时，负载调度器将成为整个集群系统的新瓶颈。大多数 <code>Internet</code> 服务都有这样的特点：请求报文较短而响应报文往往含大量的数据。如果能将请求和响应分开处理，即在负载调度器中只负责调度请求而响应直接返回给客户，将极大地提高整个集群系统的吞吐量。 <code>VS/DR</code> 的体系结构如下图所示：调度器和服务器组都必须在物理上有一个网卡通过不分断的局域相连，如通过交换机或者高速的 HUB 相连。 <code>VIP</code> 地址为调度器和服务器组共享，调度器配置的 <code>VIP</code> 地址是对外可见的，用于接收虚拟服务的请求报文；所有的服务器把 <code>VIP</code> 地址配置在各自的 <code>Non-ARP</code> 网络设备上，它对外面是不可见的，只是用于处理目标地址为 <code>VIP</code> 的网络请求。</p><center><img src="http://ovuhiuqqd.bkt.clouddn.com/LVS-DR.jpg"></center><h4 id="通过如下的VS-DR配置为例，来了解报文的结构："><a href="#通过如下的VS-DR配置为例，来了解报文的结构：" class="headerlink" title="通过如下的VS/DR配置为例，来了解报文的结构："></a>通过如下的VS/DR配置为例，来了解报文的结构：</h4><center><img src="http://ovuhiuqqd.bkt.clouddn.com/VS-DR.jpg"></center><h3 id="通过-IP-隧道实现虚拟服务器（VS-TUN）"><a href="#通过-IP-隧道实现虚拟服务器（VS-TUN）" class="headerlink" title="通过 IP 隧道实现虚拟服务器（VS/TUN）"></a>通过 IP 隧道实现虚拟服务器（VS/TUN）</h3><p>跟 <code>VS/DR</code> 方法相同， <code>VS/TUN</code> 多数 <code>Internet</code> 服务的非对称特点，负载调度器中只负责调度请求，而服务器直接将响应返回给客户，可以极大地提高整个集群系统的吞吐量。 <code>IP</code> 隧道（<code>IP tunneling</code>）是将一个 <code>IP</code> 报文封装在另一个 <code>IP</code>报文的技术，这可以使得目标为一个 IP 地址的数据报文能被封装和转发到另一个<code>IP</code> 地址。我们利用 <code>IP</code> 隧道技术将请求报文封装转发给后端服务器，响应报文能从后端服务器直接返回给客户。但在这里，后端服务器有一组而非一个，所以我们不可能静态地建立一一对应的隧道，而是动态地选择一台服务器，将请求报文封装和转发给选出的服务器。这样，我们可以利用 <code>IP</code> 隧道的原理将一组服务器上的网络服务组成在一个 <code>IP</code> 地址上的虚拟网络服务。 <code>VS/TUN</code> 的体系结构如图 3.3 所示，各个服务器将 <code>VIP</code> 地址配置在自己的 <code>IP</code> 隧道设备上。 <code>VS/TUN</code> 的体系结构如图 1.7 所示</p><center><img src="http://ovuhiuqqd.bkt.clouddn.com/VS-TUN.jpg"></center><h3 id="三种IP负载均衡技术比较"><a href="#三种IP负载均衡技术比较" class="headerlink" title="三种IP负载均衡技术比较"></a>三种IP负载均衡技术比较</h3><p>三种 IP 负载均衡技术的优缺点归纳在下表中：</p><table><thead><tr><th></th><th>VS/NAT</th><th>VS/DR</th><th>VS/TUN</th></tr></thead><tbody><tr><td>Server</td><td>any</td><td>Non-arp device</td><td>Tunneling</td></tr><tr><td>server network</td><td>private</td><td>LAN</td><td>LAN/WAN</td></tr><tr><td>server number</td><td>low (10~20)</td><td>High (100)</td><td>High (100)</td></tr><tr><td>server gateway</td><td>load balancer</td><td>Own router</td><td>own route</td></tr></tbody></table><p><code>VS/NAT</code> 的<strong>优点</strong>是服务器可以运行任何支持 <code>TCP/IP</code> 的操作系统，它只需要一个 <code>IP</code> 地址配置在调度器上，服务器组可以用私有的 <code>IP</code> 地址。<strong>缺点</strong>是它的伸缩能力有限，当服务器结点数目升到 20 时，调度器本身有可能成为系统的新瓶颈，因为在 <code>VS/NAT</code> 中请求和响应报文都需要通过负载调度器。</p><p><code>VS/DR</code> <strong>优点</strong>是负载调度器可以处理大量的请求， 因为调度器只处理客户到服务器端的连接，响应数据可以直接从独立的网络路由返回给客户， 这可以极大地提高 <code>LVS</code> 集群系统的伸缩性。 <strong>缺点</strong>是要求负载调度器与实际服务器都有块网卡连在同一物理网段上，服务器网络设备（或者设备别名）不作 <code>ARP</code> 响，或者能将报文重定向（<code>Redirec</code>）到本地的 <code>Socket</code> 端口上。</p><p><code>VS/TUN</code> 的<strong>优点</strong>是负载调度器可以处理大量的请求，它甚至可以调度百台以上的服务器（同等规模的服务器），而它不会成为系统的瓶颈，因为负载调度器只请求调度到不同的后端服务器，后端服务器将应答的数据直接返回给用户。<strong>缺点</strong>是 <code>VS/TUN</code> 技术有 <code>IP</code> 隧道的开销并且对服务器有要求，即所有的服务器必须支持“<code>IP Tunneling</code>”或者“<code>IP Encapsulation</code>”协议。</p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="http://www.linuxvirtualserver.org/" target="_blank" rel="noopener">本文多数内容来自：LVS 官方站点</a></p>]]></content>
      
      
        <tags>
            
            <tag> LVS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SNAT与DNAT</title>
      <link href="/2017/10/21/Linux-iptables-SNAT/"/>
      <url>/2017/10/21/Linux-iptables-SNAT/</url>
      <content type="html"><![CDATA[<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h4><center><img src="http://ovuhiuqqd.bkt.clouddn.com/%E9%98%B2%E7%81%AB%E5%A2%99%E5%AE%9E%E9%AA%8C.jpg"></center><a id="more"></a><h4 id="局域网主机"><a href="#局域网主机" class="headerlink" title="局域网主机"></a>局域网主机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@LAN-host ~]# ifconfig eth1            # 查看IP</span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 00:0C:29:DE:D2:8C  </span><br><span class="line">          inet addr:192.168.8.128  Bcast:192.168.8.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::20c:29ff:fede:d28c/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:154351 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:9823 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:220149822 (209.9 MiB)  TX bytes:959486 (936.9 KiB)</span><br><span class="line">[root@LAN-host ~]# ip route             # 查看路由，配置SNAT、DNAT都需要将忘光指向192.168.8.140</span><br><span class="line">192.168.8.0/24 dev eth1  proto kernel  scope link  src 192.168.8.128 </span><br><span class="line">169.254.0.0/16 dev eth1  scope link  metric 1003 </span><br><span class="line">default via 192.168.8.140 dev eth1</span><br></pre></td></tr></table></figure><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@Firewalld ~]# ifconfig        # 查看IP</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.18.251.146  netmask 255.255.0.0  broadcast 172.18.255.255</span><br><span class="line">        inet6 fe80::250:56ff:fe34:70b8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:50:56:34:70:b8  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 106496  bytes 8353964 (7.9 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 493  bytes 42866 (41.8 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens34: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.8.140  netmask 255.255.255.0  broadcast 192.168.8.255</span><br><span class="line">        inet6 fe80::250:56ff:fe37:a834  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:50:56:37:a8:34  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 4622  bytes 397342 (388.0 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2833  bytes 324367 (316.7 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1  (Local Loopback)</span><br><span class="line">        RX packets 68  bytes 5876 (5.7 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 68  bytes 5876 (5.7 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@Firewalld ~]# echo 1 &gt; /proc/sys/net/ipv4/ip_forward          # 开启防火墙的路由功能</span><br><span class="line">[root@Firewalld ~]# cat /proc/sys/net/ipv4/ip_forward</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="互联网主机"><a href="#互联网主机" class="headerlink" title="互联网主机"></a>互联网主机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@WAN-host ~]# ifconfig ens33           # 查看IP</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.18.252.112  netmask 255.255.0.0  broadcast 172.18.255.255</span><br><span class="line">        inet6 fe80::20c:29ff:feba:242e  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:ba:24:2e  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 301840  bytes 27336566 (26.0 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 3790  bytes 497705 (486.0 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">[root@WAN-host ~]# ping 192.168.8.128 -c 1          # 在互联网主机是无法ping通局域网主机的</span><br><span class="line">PING 192.168.8.128 (192.168.8.128) 56(84) bytes of data.</span><br><span class="line"></span><br><span class="line">--- 192.168.8.128 ping statistics ---</span><br><span class="line">1 packets transmitted, 0 received, 100% packet loss, time 0ms</span><br></pre></td></tr></table></figure><h3 id="SNAT策略"><a href="#SNAT策略" class="headerlink" title="SNAT策略"></a>SNAT策略</h3><h4 id="SNAT工作原理"><a href="#SNAT工作原理" class="headerlink" title="SNAT工作原理"></a>SNAT工作原理</h4><p><code>SNAT</code>：<strong>将请求报文的源地址替换为防火墙所定义的源地址。</strong></p><center><img src="http://ovuhiuqqd.bkt.clouddn.com/SNAT.jpg"></center><h4 id="配置SNAT"><a href="#配置SNAT" class="headerlink" title="配置SNAT"></a>配置SNAT</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 访问互联网80端口时，将源IP转换为防火墙的IP</span><br><span class="line"></span><br><span class="line">[root@Firewalld ~]# iptables -t nat -A POSTROUTING -s 192.168.8.0/24 -j SNAT --to-source 172.18.251.146</span><br><span class="line">        # 定义规则：将192.168.8.0网段访问外部IP时，转换为172.18.251.146</span><br><span class="line">[root@Firewalld ~]# iptables -vnL POSTROUTING -t nat </span><br><span class="line">Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    1    84 SNAT       all  --  *      *       192.168.8.0/24       0.0.0.0/0            to:172.18.251.146</span><br><span class="line"></span><br><span class="line">[root@LAN-host ~]# ping -c 2 172.18.252.112         # 在内网主机ping互联网主机，是可以ping通的</span><br><span class="line">PING 172.18.252.112 (172.18.252.112) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.252.112: icmp_seq=1 ttl=63 time=0.596 ms</span><br><span class="line">64 bytes from 172.18.252.112: icmp_seq=2 ttl=63 time=1.31 ms</span><br><span class="line"></span><br><span class="line">--- 172.18.252.112 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1005ms</span><br><span class="line">rtt min/avg/max/mdev = 0.596/0.955/1.314/0.359 ms</span><br><span class="line"></span><br><span class="line">[root@WAN-host ~]# tcpdump -i ens33 icmp -nn        # 通过tcpdump抓包查看，可以看到是172.18.251.146去ping172.18.252.112的</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on ens33, link-type EN10MB (Ethernet), capture size 65535 bytes</span><br><span class="line">22:45:17.891996 IP 172.18.251.146 &gt; 172.18.252.112: ICMP echo request, id 20754, seq 1, length 64</span><br><span class="line">22:45:17.892047 IP 172.18.252.112 &gt; 172.18.251.146: ICMP echo reply, id 20754, seq 1, length 64</span><br><span class="line">22:45:18.894542 IP 172.18.251.146 &gt; 172.18.252.112: ICMP echo request, id 20754, seq 2, length 64</span><br><span class="line">22:45:18.894586 IP 172.18.252.112 &gt; 172.18.251.146: ICMP echo reply, id 20754, seq 2, length 64</span><br><span class="line">^C</span><br><span class="line">4 packets captured</span><br><span class="line">4 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br><span class="line"></span><br><span class="line">[root@LAN-host ~]# curl 172.18.252.112</span><br><span class="line">www.ihaiyun.cc</span><br><span class="line"></span><br><span class="line">[root@WAN-host ~]# tail -1 /var/log/httpd/access_log       # 查看http服务访问日志，可以看到是172.18.251.146去访问172.18.252.112的 </span><br><span class="line">172.18.251.146 - - [20/Oct/2017:22:47:14 +0800] &quot;GET / HTTP/1.1&quot; 200 15 &quot;-&quot; &quot;curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.21 Basic ECC zlib/1.2.3 libidn/1.18 libssh2/1.4.2&quot;</span><br></pre></td></tr></table></figure><h3 id="拨号SNAT策略"><a href="#拨号SNAT策略" class="headerlink" title="拨号SNAT策略"></a>拨号SNAT策略</h3><p><strong>拨号SNAT策略主要是为了解决通过拨号上网IP地址不固定的状况。拨号SNAT的效率没有固定IP SNAT策略效率高。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 访问互联网80端口时，将源IP转换为防火墙的IP</span><br><span class="line"></span><br><span class="line">[root@Firewalld ~]# iptables -t nat -A POSTROUTING -s 192.168.8.0/24 -j MASQUERADE      # 修改后面为MASQUERADE策略，解决了拨号上网IP不固定的情况</span><br><span class="line">[root@Firewalld ~]# iptables -vnL POSTROUTING -t nat        # 查看nat表</span><br><span class="line">Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    0     0 MASQUERADE  all  --  *      *       192.168.8.0/24       0.0.0.0/0        </span><br><span class="line"></span><br><span class="line">[root@LAN-host ~]# curl 172.18.252.112      # 在局域网主机访问测试</span><br><span class="line">www.ihaiyun.cc</span><br><span class="line"></span><br><span class="line">[root@WAN-host ~]# tail -1 /var/log/httpd/access_log            # 查看日志</span><br><span class="line">172.18.251.146 - - [20/Oct/2017:23:04:32 +0800] &quot;GET / HTTP/1.1&quot; 200 15 &quot;-&quot; &quot;curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.21 Basic ECC zlib/1.2.3 libidn/1.18 libssh2/1.4.2&quot;</span><br></pre></td></tr></table></figure><h3 id="DNAT策略"><a href="#DNAT策略" class="headerlink" title="DNAT策略"></a>DNAT策略</h3><h4 id="DNAT工作原理"><a href="#DNAT工作原理" class="headerlink" title="DNAT工作原理"></a>DNAT工作原理</h4><p><code>DNAT</code>：<strong>将请求报文的目标地址替换为防火墙所定义的目标地址。</strong></p><center><img src="http://ovuhiuqqd.bkt.clouddn.com/DNAT.jpg"></center><h4 id="配置DNAT"><a href="#配置DNAT" class="headerlink" title="配置DNAT"></a>配置DNAT</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 将访问防火墙的80端口转发到局域网的80端口</span><br><span class="line"></span><br><span class="line">[root@Firewalld ~]# iptables -t nat -A PREROUTING -s 0/0 -d 0/0 -p tcp --dport 80 -j DNAT --to-destination 192.168.8.128          # 将外网访问防火墙的80端口转发给内网</span><br><span class="line">[root@Firewalld ~]# iptables -vnL -t nat </span><br><span class="line">Chain PREROUTING (policy ACCEPT 1 packets, 207 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    1    60 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:192.168.8.128</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 1 packets, 207 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 1 packets, 60 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">[root@WAN-host ~]# curl 172.18.251.146      # 在互联主机测试访问防火墙的80端口</span><br><span class="line">www.ihaiyun.cc</span><br><span class="line"></span><br><span class="line">[root@LAN-host ~]# tail -1 /var/log/httpd/access_log        # 查看日志</span><br><span class="line">172.18.252.112 - - [20/Oct/2017:13:26:35 +0800] &quot;GET / HTTP/1.1&quot; 200 15 &quot;-&quot; &quot;curl/7.29.0&quot;</span><br></pre></td></tr></table></figure><h3 id="转发REDIRECT"><a href="#转发REDIRECT" class="headerlink" title="转发REDIRECT"></a>转发REDIRECT</h3><p><strong>将访问本地端口请求，转发到本地的其它端口。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 将访问本地1234端口转发到本地的80端口</span><br><span class="line"></span><br><span class="line">[root@Firewalld ~]# iptables -t nat -A PREROUTING -d 0/0 -p tcp --dport 1234 -j REDIRECT --to-port 80       # 基于上面实验的基础，配置端口转发，当访问本地1234端口时就转发到本地的80端口</span><br><span class="line">[root@Firewalld ~]# iptables -vnL -t nat </span><br><span class="line">Chain PREROUTING (policy ACCEPT 105 packets, 19073 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    8   480 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:192.168.8.128</span><br><span class="line">    1    60 REDIRECT   tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:1234 redir ports 80</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 102 packets, 18181 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 4 packets, 304 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 4 packets, 304 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination  </span><br><span class="line"></span><br><span class="line">[root@WAN-host ~]# curl 172.18.251.146:1234         # 可以访问</span><br><span class="line">www.ihaiyun.cc</span><br><span class="line">[root@LAN_host ~]# tail -1 /var/log/httpd/access_log        # 查看访问日志</span><br><span class="line">172.18.252.112 - - [21/Oct/2017:21:36:19 +0800] &quot;GET / HTTP/1.1&quot; 200 15 &quot;-&quot; &quot;curl/7.29.0&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Iptables </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IP地址</title>
      <link href="/2017/09/01/Linux-IP-Address-2017-09-01/"/>
      <url>/2017/09/01/Linux-IP-Address-2017-09-01/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），缩写为IP地址（英语：IP Address），是分配给网络上使用网际协议（英语：Internet Protocol, IP）的设备的数字标签。常见的IP地址分为IPv4与IPv6两大类。</p><center><img src="http://ovuhiuqqd.bkt.clouddn.com/IP%E5%9B%BE%E7%89%872.jpg"></center><a id="more"></a><p>IP地址是在计算机网络中被用来唯一标识一台设备的一组数字，各个节点（设备）之间使用IP协议进行通信。IP地址的层次是按网络结构进行划分，一个IP地址是由网络号和主机号两部分组成。</p><h3 id="IP地址组成"><a href="#IP地址组成" class="headerlink" title="IP地址组成"></a>IP地址组成</h3><p><strong>IP地址有两部分组成：</strong></p><p><strong>网络号码字段（net-id）：</strong></p><ul><li>用于区分不同网络。网络号码字段的前几位称为类别字段（又称为类别比特），用来区分IP地址的类型。</li></ul><p><strong>主机ID（host-id）：</strong></p><ul><li>用于区分一个网络内的不同主机</li></ul><p>IP地址的网络号码字段用来标识一个网络，主机号码字段用来标识网络中网络设备的一个连接。如果有多台网络设备，无论它们分别处于任何物理位置，只要它们具有相同的网络号，那他们就处在同一网络中。也就是说，在公共网络内的多台网络设备是否处于相同网络与它们所处的物理位置无关。</p><h3 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h3><p>IP地址由32位二进制数值组成，但为了便于用户识别和记忆，采用了“点分十进制表示法”。采用了这种表示法的IP地址由4个由点分隔的十进制整数来表示，每个十进制整数对应一个字节。例如，A主机的IP地址使用二进制的表示形式为00001010 00000001 00000001 00000010，采用点分十进制表示法表示为10.1.1.2。</p><p>IP地址是唯一的。目前IP技术可能使用的IP地址最多可有4,294,967,296个（即232）。骤看可能觉得很难会用尽，但由于早期编码和分配上的问题，使很多区域的编码实际上被空出或不能使用。加上互联网的普及，使大部分家庭都至少有一部电脑，连同公司的电脑，以及连接网络的各种设备都消耗了大量IPv4地址资源。</p><p>随着互联网的快速成长，IPv4的42亿个地址的分配最终于2011年2月3日用尽。相应的科研组织已研究出128位的 IPv6，其IP地址数量最高可达3.402823669 × 1038个，届时每个人家居中的每件电器，每件对象，甚至地球上每一粒沙子都可以拥有自己的IP地址。</p><h4 id="地址分类"><a href="#地址分类" class="headerlink" title="地址分类"></a>地址分类</h4><p>地址可分为A、B、C、D、E五大类，其中E类属于特殊保留地址。</p><center><img src="http://ovuhiuqqd.bkt.clouddn.com/IP.jpg"></center><p>通过网络号码字段的前几个比特就可以判断IP地址属于哪一类，这是区分各类地址最简单的方法。</p><h4 id="地址范围"><a href="#地址范围" class="headerlink" title="地址范围"></a>地址范围</h4><p>在A类、B类、C类IP地址中，如果主机号是全1，那么这个地址为直接广播地址，它是用来使路由器将一个分组以广播形式发送给特定网络上的所有主机。32位全为1的IP地址“255.255.255.255”为受限广播地址（”limited broadcast” destination address），用来将一个分组以广播方式发送给本网络中的所有主机，路由器则阻挡该分组通过，将其广播功能限制在本网内部。</p><table><thead><tr><th>网络类型</th><th>地址范围</th><th>用户可用的IP网络范围</th><th>说明</th></tr></thead><tbody><tr><td>A</td><td>0.0.0.0～127.255.255.255</td><td>1.0.0.0～126.0.0.0</td><td>全0的主机号码表示该IP地址就是网络的地址，用于网络路由；全1的主机号码表示广播地址，即对该网络上所有的主机进行广播；IP地址0.0.0.0仅在采用DHCP方式的系统启动时允许本主机利用它进行临时的通信，并且永远不是有效目的地址；网络号码为0的IP地址表示当前网络的主机，可以让机器引用自己的网络而不必知道其网络号；所有形如127.X.Y.Z的地址都保留作环回测试，发送到这个地址的分组不会输出到线路上，它们被内部处理并当作输入分组。</td></tr><tr><td>B</td><td>128.0.0.0～191.255.255.255</td><td>128.1.0.0～191.254.0.0</td><td>全0的主机号码表示该IP地址就是网络的地址，用于网络路由；全1的主机号码表示广播地址，即对该网络上所有的主机进行广播。</td></tr><tr><td>C</td><td>192.0.0.0～223.255.255.255</td><td>192.0.1.0～223.255.254.0</td><td>全0的主机号码表示该IP地址就是网络的地址，用于网络路由；全1的主机号码表示广播地址，即对该网络上所有的主机进行广播。</td></tr><tr><td>D</td><td>224.0.0.0～239.255.255.255</td><td>无</td><td>D类地址是一种组播地址。</td></tr><tr><td>E</td><td>240.0.0.0～255.255.255.255</td><td>无</td><td>保留。255.255.255.255用于局域网广播地址。</td></tr></tbody></table><h4 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h4><table><thead><tr><th>IP地址网络号</th><th>IP地址子网号</th><th>IP地址主机号</th><th>能否作为源端地址</th><th>能否作为目的端地址</th><th>描述</th></tr></thead><tbody><tr><td>全0</td><td>-</td><td>全0</td><td>可以</td><td>不可以</td><td>用于网络上的主机</td></tr><tr><td>全0</td><td>-</td><td>主机号</td><td>可以</td><td>不可以</td><td>用于网络上的特定主机</td></tr><tr><td>127</td><td>-</td><td>任何值</td><td>可以</td><td>可以</td><td>用于环回地址</td></tr><tr><td>全1</td><td>-</td><td>全1</td><td>不可以</td><td>可以</td><td>用于受限的广播（永远不被转发）</td></tr><tr><td>net-id</td><td>-</td><td>全1</td><td>不可以</td><td>可以</td><td>用于向以net-id为目的的网络广播</td></tr><tr><td>net-id</td><td>subnet-id</td><td>全1</td><td>不可以</td><td>可以</td><td>用于向以net-id，subnet-id为目的的子网广播</td></tr><tr><td>net-id</td><td>全1</td><td>全1</td><td>不可以</td><td>可以</td><td>用于向以net-id为目的的所有子网广播</td></tr></tbody></table><h4 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h4><p>为了解决IP地址短缺的问题，提出了私有地址的概念。私有地址是指内部网络或主机地址，这些地址只能用于某个内部网络，不能用于公共网络。RFC1918描述了为私有网络预留的3个IP地址段。</p><p>IP地址分配组织规定将下列的IP地址保留用作私有地址，如下</p><table><thead><tr><th>网络类型</th><th>地址范围</th></tr></thead><tbody><tr><td>A</td><td>10.0.0.0～10.255.255.255</td></tr><tr><td>B</td><td>172.16.0.0～172.31.255.255</td></tr><tr><td>C</td><td>192.168.0.0～192.168.255.255</td></tr></tbody></table><h3 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h3><p>从IPv4到IPv6最显著的变化就是网络地址的长度，有128位长；IPv6地址的表达形式，一般采用32个十六进制数。</p><p>本文中大多数IP地址指的是IPv4地址，不对IPv6做过多讲解。</p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="https://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">维基百科：IP地址</a><br><a href="http://support.huawei.com/enterprise/docinforeader!loadDocument1.action?contentId=DOC0000645520&amp;partNo=10092" target="_blank" rel="noopener">华为：IP地址</a></p>]]></content>
      
      
        <tags>
            
            <tag> 网络管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>脚本实例一：创建脚本的脚本</title>
      <link href="/2017/08/25/Linux-shell-script1-2017-08-25/"/>
      <url>/2017/08/25/Linux-shell-script1-2017-08-25/</url>
      <content type="html"><![CDATA[<h3 id="脚本实例一：创建脚本的脚本"><a href="#脚本实例一：创建脚本的脚本" class="headerlink" title="脚本实例一：创建脚本的脚本"></a>脚本实例一：创建脚本的脚本</h3><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">read -p "please input scrpit name: " NAME# 输入脚本名</span><br><span class="line">[ -f $NAME ] &amp;&amp;  &#123; echo "$NAME" is already exists &amp;&amp; exit 100 ; &#125;# 判断文件是否存在，如果存在就退出</span><br><span class="line">touch $NAME &amp;&gt; /dev/null            # 创建文件</span><br><span class="line">chmod +x $NAME &amp;&gt; /dev/null # 添加执行权限</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 向脚本输入一下描述内容</span><br><span class="line">cat &gt; $NAME &lt;&lt; END</span><br><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>——————————————————————————————————————————————</span><br><span class="line"><span class="meta">#</span> File name: $NAME</span><br><span class="line"><span class="meta">#</span> Revision: 2.0</span><br><span class="line"><span class="meta">#</span> Date: `date '+%F %T'`</span><br><span class="line"><span class="meta">#</span> Author: houhaiyun</span><br><span class="line"><span class="meta">#</span> Email: houhaiyun18@163.com</span><br><span class="line"><span class="meta">#</span> Website: http://www.ihaiyun.cc/</span><br><span class="line"><span class="meta">#</span> Copyright: @2017 haiyun</span><br><span class="line"><span class="meta">#</span> License: LGPL v3</span><br><span class="line"><span class="meta">#</span> Description:  </span><br><span class="line"><span class="meta">#</span>——————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">vim + $NAME # 编辑完成直接打开脚本文件且定位到最后一行，方便编辑</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> END———————————————————————————————————————————</span><br></pre></td></tr></table></figure><h3 id="脚本功能："><a href="#脚本功能：" class="headerlink" title="脚本功能："></a>脚本功能：</h3><p>使用此脚本创建的脚本自动添加执行权限，并添加描述信息，最后直接打开脚本文件，直接编辑。是不是很方便呢？</p><h3 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h3><center><img src="http://ovuhiuqqd.bkt.clouddn.com/%E8%84%9A%E6%9C%AC%E5%AE%9E%E4%BE%8B%E4%B8%80.gif"></center>]]></content>
      
      
        <tags>
            
            <tag> 脚本实例 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell 变量简介</title>
      <link href="/2017/08/20/Linux-Shell-bianliang/"/>
      <url>/2017/08/20/Linux-Shell-bianliang/</url>
      <content type="html"><![CDATA[<center><img src="https://houhaiyun.github.io/img/images/Linux-Shell-bianliang.jpg" title="Bash"></center><a id="more"></a><h3 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h3><p>在程序设计中，变数（英语：<code>variable，scalar</code>）是指一个包含部分已知或未知数值或资讯（即一个值）之储存位址，以及相对应之符号名称（识别字）。通常使用变数名称参照储存值；将名称和内容分开能让被使用的名称独立于所表示的精确讯息之外。电脑源代码中的识别字能在执行期间绑扎一个值，且该变数的值可能在程式执行期间改变。 程序设计中的变数不一定能直接对应到数学中所谓的变数之概念。在程序设计中，变数的值不一定要为方程或数学公式之一部分。程序设计中的变数可使用在一段可重复的程序：在一处赋值，然后使用于另一处，接着在一次赋值，且以相同方式再使用一次（见迭代）。程序设计中的变数通常会给定一个较长的名称，以描述其用途；数学中的变数通常较为简洁，只给定一、两个字母，以方便抄写及操作。</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>强类型：变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。一般定义变量时必须指定类型、参与运算必须符合类型要求；调用未声明变量会产生错误 <ul><li>如：<code>java</code>，<code>c#</code></li></ul></li><li>弱类型：语言的运行时会隐式做数据类型转换。无须指定类型，默认均为字符型；参与运算会自动进行隐式类型转换；变量无须事先定义可直接调用 <ul><li>如：<code>bash</code>不支持浮点数，<code>php</code></li></ul></li></ul><h3 id="shell变量命名规则"><a href="#shell变量命名规则" class="headerlink" title="shell变量命名规则"></a>shell变量命名规则</h3><ol><li>不能使程序中的保留字：例如<code>if</code>, <code>for</code></li><li>只能使用数字、字母及下划线，且不能以数字开头</li><li>见名知义</li><li>统一命名规则：驼峰命名法 </li></ol><h3 id="shell变量种类"><a href="#shell变量种类" class="headerlink" title="shell变量种类"></a>shell变量种类</h3><p><strong>根据变量的生效范围等标准：</strong></p><ul><li>本地变量：生效范围为当前<code>shell</code>进程；对当前<code>shell</code>之外的其它<code>shell</code>进程，包括当前<code>shell</code>的子<code>shell</code>进程均无效 </li><li>环境变量：生效范围为当前<code>shell</code>进程及其子进程 </li><li>局部变量：生效范围为当前<code>shell</code>进程中某代码片断(通常指函数) </li><li>位置变量： <code>$1</code>, <code>$2</code>, …来表示，用于让脚本在脚本代码中调用通过命令行传递给它的参数 </li><li>特殊变量： <code>$?</code>, <code>$0</code>, <code>$*</code>, <code>$@</code>, <code>$#</code>,<code>$$</code> </li></ul><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">维基百科：变量</a></p>]]></content>
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> shell脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell变量 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>硬盘结构</title>
      <link href="/2017/08/02/Linux-Disk-jiegou-2017-08-02/"/>
      <url>/2017/08/02/Linux-Disk-jiegou-2017-08-02/</url>
      <content type="html"><![CDATA[<h3 id="硬盘盘结构"><a href="#硬盘盘结构" class="headerlink" title="硬盘盘结构"></a>硬盘盘结构</h3><p>硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组（<strong>磁头</strong>）到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（<strong>磁轨</strong>或称<strong>柱面</strong>），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位<strong>扇区</strong>，从而得到该扇区的数据内容；</p><a id="more"></a><center><img src="http://ovuhiuqqd.bkt.clouddn.com/%E7%A1%AC%E7%9B%98%E7%BB%93%E6%9E%84.jpg"></center><ul><li>磁道</li></ul><p>当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。</p><ul><li>柱面</li></ul><p>在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。</p><ul><li>扇区</li></ul><p>磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。硬盘的第一个扇区，叫做引导扇区。</p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98#.E7.89.A9.E7.90.86.E7.BB.93.E6.9E.84" target="_blank" rel="noopener">维基百科：硬盘</a></p>]]></content>
      
      
        <tags>
            
            <tag> 磁盘管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>硬盘</title>
      <link href="/2017/08/01/Linux-Disk-2017-08-01/"/>
      <url>/2017/08/01/Linux-Disk-2017-08-01/</url>
      <content type="html"><![CDATA[<h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><p>机械硬盘（<code>HDD</code>）：<code>Hard Disk Drive</code>，即是传统普通硬盘，主要由：盘片，磁头，盘片转轴及控制电机，磁头控制器，数据转换器，接口，缓存等几个部分组成。机械硬盘中所有的盘片都装在一个旋转轴上，每张盘片之间是平行的，在每个盘片的存储面上有一个磁头，磁头与盘片之间的距离比头发丝的直径还小，所有的磁头联在一个磁头控制器上，由磁头控制器负责各个磁头的运动。磁头可沿盘片的半径方向运动，加上盘片每分钟几千转的高速旋转，磁头就可以定位在盘片的指定位置上进行数据的读写操作。数据通过磁头由电磁流来改变极性方式被电磁流写到磁盘上，也可以通过相反方式读取。硬盘为精密设备，进入硬盘的空气必须过滤。</p><a id="more"></a><center><img src="http://ovuhiuqqd.bkt.clouddn.com/%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98.jpg"></center><h4 id="数据接口"><a href="#数据接口" class="headerlink" title="数据接口"></a>数据接口</h4><p>硬盘按数据接口不同，大致分为<code>ATA</code>（<code>IDE</code>）和<code>SATA</code>以及<code>SCSI</code>和<code>SAS</code>。接口速度不是实际硬盘数据传输的速度，目前非基于闪存技术的硬盘数据实际传输速度一般不会超过300MB/s。</p><p><code>ATA</code>，全称<code>Advanced Technology Attachment</code>，是用传统的<code>40-pin</code>并口数据线连接主板与硬盘的，接口速度最大为133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被<code>SATA</code>所取代。</p><p><code>SATA</code>，全称<code>Serial ATA</code>，也就是使用串口的<code>ATA</code>接口，因抗干扰性强，且对数据线的长度要求比<code>ATA</code>低很多，支持热插拔等功能，<code>SATA-II</code>的接口速度为<code>300MiB/s</code>，而新的<code>SATA-III</code>标准可达到<code>600MiB/s</code>的传输速度。<code>SATA</code>的数据线也比<code>ATA</code>的细得多，有利于机箱内的空气流通，整理线材也比较方便。</p><p><code>SCSI</code>，全称是<code>Small Computer System Interface</code>（小型机系统接口），经历多代的发展，从早期的<code>SCSI-II</code>，到目前的<code>Ultra320 SCSI</code>以及<code>Fiber-Channel</code>（光纤通道），接口型式也多种多样。<code>SCSI</code>硬盘广为工作站级个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速<code>15000rpm</code>的高转速，且资料传输时<code>CPU</code>占用率较低，但是单价也比相同容量的<code>ATA</code>及<code>SATA</code>硬盘更加昂贵。</p><p><code>SAS</code>（<code>Serial Attached SCSI</code>）是新一代的<code>SCSI</code>技术，和<code>SATA</code>硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到<code>6Gb/s</code>。此外也透过缩小连接线改善系统内部空间等。此外，由于<code>SAS</code>硬盘可以与<code>SATA</code>硬盘共享同样的背板，因此在同一个<code>SAS</code>存储系统中，可以用<code>SATA</code>硬盘来取代部分昂贵的<code>SAS</code>硬盘，节省整体的存储成本。但<code>SATA</code>存储系统并不能连接<code>SAS</code>硬盘。</p><p><code>FC</code>（<code>Fibre Channel</code>，光纤通道接口），拥有此接口的硬盘在使用光纤联接时具有热插拔性、高速带宽（<code>4Gb/s</code>或<code>10Gb/s</code>）、远程连接等特点；内部传输速率也比普通硬盘更高。限制于其高昂的售价，通常用于高端服务器领域。</p><h5 id="RPM转速"><a href="#RPM转速" class="headerlink" title="RPM转速"></a>RPM转速</h5><p>主要用于表征机械转子的转速，硬盘转速也可用此表示。</p><p><code>RPM =round per minute</code> 每分钟多少转</p><h4 id="电源接口"><a href="#电源接口" class="headerlink" title="电源接口"></a>电源接口</h4><p><code>3.5</code>寸的台式机硬盘，与<code>ATA</code>配合使用的是“<code>D形4针电源接口</code>”（俗称“<code>大4pin</code>”），由<code>Molex</code>公司设计并持有专利；而<code>SATA</code>接口也有相应的<code>SATA</code>电源线。</p><p><code>2.5</code>寸的笔记本电脑用硬盘，可直接由数据口供电，不需要额外的电源接口。在插上外接的便携式硬盘盒之后，由计算机外部的<code>USB</code>接口提供电力来源，而单个<code>USB</code>接口供电约为<code>4~5V 500mA</code>，若移动硬盘盒用电需求较高，有时需要接上两个<code>USB</code>接口才能使用，否则，需要外接电源供电。但如今多数新型硬盘盒（使用<code>2.5寸</code>或以下硬盘）已可方便地使用单个<code>USB</code>口供电。</p><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><p>固态硬盘（<code>SSD</code>）： <code>Solid State Drive</code>，用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（<code>FLASH</code>芯片、 <code>DRAM</code>芯片）组成。固态硬盘在接口的规范和定义、功能及使用方法上与普通硬盘的完全相同，在产品外形和尺寸上也与普通硬盘一致。</p><p>本文中只对固态硬盘简单了解。</p><center><img src="http://ovuhiuqqd.bkt.clouddn.com/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98.jpg"></center>]]></content>
      
      
        <tags>
            
            <tag> 硬盘 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux Shell</title>
      <link href="/2017/07/07/Linux-Shell/"/>
      <url>/2017/07/07/Linux-Shell/</url>
      <content type="html"><![CDATA[<p><center><img src="https://houhaiyun.github.io/img/images/Linux-Shell.jpg" title="Linux Shell"></center><br><a id="more"></a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>计算机理解了被称为二进制语言的零语言。在计算的早期，使用二进制语言提供了指令，这对我们所有人来说都是难以阅读和写入的。因此，在操作系统中有一个称为<code>shell</code>的特殊程序。<code>shell</code>接受人类可读命令并将其转换为内核可以读取和处理的内容。</p><h3 id="什么是shell？"><a href="#什么是shell？" class="headerlink" title="什么是shell？"></a>什么是shell？</h3><ul><li><code>shell</code>是一个用户程序，也是为用户交互提供的环境。</li><li>它是一个命令语言解释器，执行从标准输入设备（如键盘或文件）读取的命令。</li><li>当您登录或打开控制台（终端）时，<code>shell</code>将启动。</li><li>快速而脏的方式来执行实用程序。</li><li><code>shell</code>不是系统内核的一部分，而是使用系统内核执行程序，创建文件等。</li></ul><h3 id="Linux提供的shell"><a href="#Linux提供的shell" class="headerlink" title="Linux提供的shell"></a>Linux提供的shell</h3><ul><li><code>BASH</code>（<code>Bourne-Again SHELL</code>） - <code>Linux</code>中最常见的<code>shell</code>。它是开源的，CentOS默认使用 。</li><li><code>CSH</code>（<code>C SHELL</code>） - <code>C shell</code>的语法和用法与<code>C</code>编程语言非常相似。</li><li><code>KSH</code>（<code>Korn shell</code>中） -创建者戴维·科恩在<code>AT＆T</code>贝尔实验室。<code>Korn Shell</code>是<code>POSIX Shell</code>标准规范的基础。</li><li><code>TCSH</code> - 它是<code>Berkeley UNIX C shell</code>（<code>CSH</code>）的增强但完全兼容的版本。</li></ul><p>请注意，每个<code>shell</code>执行相同的作业，但每个<code>shell</code>都会了解不同的命令语法，并提供不同的内置函数。在<code>Windows</code>下，<code>shell</code>名称是<code>cmd.exe</code>，它也用于相同的目的，但它远远不如我们的<code>Linux Shells</code>那么强大！</p><h4 id="显示当前shell"><a href="#显示当前shell" class="headerlink" title="显示当前shell"></a>显示当前shell</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]# echo $SHELL#此命令可以显示当前使用的shell，当前使用的为BASH</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><h4 id="查看当前系统支持的所有shell"><a href="#查看当前系统支持的所有shell" class="headerlink" title="查看当前系统支持的所有shell"></a>查看当前系统支持的所有shell</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]# cat /etc/shells </span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/usr/sbin/nologin</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br></pre></td></tr></table></figure><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="https://bash.cyberciti.biz/guide/What_is_Linux_Shell" target="_blank" rel="noopener">维基百科：What is Linux Shell</a></p>]]></content>
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GUI和CLI</title>
      <link href="/2017/07/06/Linux-GUI-CLI-2017-07-06/"/>
      <url>/2017/07/06/Linux-GUI-CLI-2017-07-06/</url>
      <content type="html"><![CDATA[<h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p>图形用户界面（<code>Graphical User Interface</code>，简称<code>GUI</code>）是指采用图形方式显示的计算机操作用户界面。与早期计算机使用的命令行界面相比，图形界面对于用户来说在视觉上更易于接受。</p><a id="more"></a><center><img src="http://ovuhiuqqd.bkt.clouddn.com/CLI%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2.jpg"></center><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>命令行界面（英语：<code>command-line interface</code>，缩写：<code>CLI</code>）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（<code>character user interface</code>, <code>CUI</code>）。</p><center><img src="http://ovuhiuqqd.bkt.clouddn.com/GUI%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2.jpg"></center><p><strong>一般我们是使用<code>CLI</code>的，比较酷。。。</strong></p>]]></content>
      
      
        <tags>
            
            <tag> GUI和CLI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>终端 Terminal</title>
      <link href="/2017/07/05/Linux-Terminal/"/>
      <url>/2017/07/05/Linux-Terminal/</url>
      <content type="html"><![CDATA[<center><img src="https://houhaiyun.github.io/img/images/Linux-Terminal.png" title="终端"></center><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>终端（<code>Terminal</code>）也称终端设备，是计算机网络中处于网络最外围的设备，主要用于用户信息的输入以及处理结果的输出等。</p><p>Linux系统的终端主要包括设备终端、物理终端、虚拟终端、图形终端、串行终端和伪终端</p><p><strong>查看当前的终端设备：#tty</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]# tty#这就是一个伪终端</span><br><span class="line">/dev/pts/1</span><br><span class="line">[root@centos6 ~]#</span><br></pre></td></tr></table></figure><h4 id="1-设备终端"><a href="#1-设备终端" class="headerlink" title="1.设备终端"></a>1.设备终端</h4><p>键盘鼠标显示器</p><h4 id="2-物理终端"><a href="#2-物理终端" class="headerlink" title="2.物理终端"></a>2.物理终端</h4><p>在Unix系统中，计算机显示器通常被称为控制台终端。Console与虚拟终端相关联，内核将信息送到控制台上（/dev/console），通过与console相关联的虚拟终端将信息显示到屏幕上。</p><h4 id="3-虚拟终端"><a href="#3-虚拟终端" class="headerlink" title="3.虚拟终端"></a>3.虚拟终端</h4><p>虚拟终端，ctrl+alt+f[1-6]切换的就是虚拟终端</p><h4 id="4-图形终端（-dev-tty7）StartlX，xwindows"><a href="#4-图形终端（-dev-tty7）StartlX，xwindows" class="headerlink" title="4.图形终端（/dev/tty7）StartlX，xwindows"></a>4.图形终端（/dev/tty7）StartlX，xwindows</h4><p>Centos 6：Ctrl+Alt+F7</p><p>Centos 7：在哪个终端启动，即位于那个虚拟终端</p><h4 id="5-串行终端（-dev-ttyS-）"><a href="#5-串行终端（-dev-ttyS-）" class="headerlink" title="5.串行终端（/dev/ttyS#）"></a>5.串行终端（/dev/ttyS#）</h4><p>通过串口线连接的终端</p><h4 id="6-伪终端（pty：pseudo-tty，-dev-pts-）"><a href="#6-伪终端（pty：pseudo-tty，-dev-pts-）" class="headerlink" title="6.伪终端（pty：pseudo-tty，/dev/pts/#）"></a>6.伪终端（pty：pseudo-tty，/dev/pts/#）</h4><p>pty,SSH远程连接</p><h3 id="wall命令"><a href="#wall命令" class="headerlink" title="wall命令"></a>wall命令</h3><p><code>wall</code>命令用于向系统当前所有打开的终端上输出信息。通过<code>wall</code>命令可将信息发送给每位同意接收公众信息的终端机用户，若不给予其信息内容，则<code>wall</code>命令会从标准输入设备读取数据，然后再把所得到的数据传送给所有终端机用户。</p><p><strong>语法</strong></p><p><code>wall 参数（消息：指定广播消息）</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">    [root@centos6 ~]# wall houhaiyum.com</span><br><span class="line">    [root@centos6 ~]# </span><br><span class="line">    Broadcast message from root@centos6.magedu.com (pts/5) (Fri Jul 14 22:28:19 2017):</span><br><span class="line">    </span><br><span class="line">    houhaiyun.com</span><br></pre></td></tr></table></figure><h3 id="mesg命令"><a href="#mesg命令" class="headerlink" title="mesg命令"></a>mesg命令</h3><p> mesg命令用于设置当前终端的写权限，即是否让其他用户向本终端发信息。将mesg设置y时，其他用户可利用write命令将信息直接显示在您的屏幕上。</p><p><strong>语法</strong></p><p><code>mesg 参数</code></p><p>y/n：y表示运行向当前终端写信息，n表示禁止向当前终端写信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">    [root@centos6 ~]# mesg y    #允许系统用户将信息直接显示在你的屏幕上。</span><br><span class="line">    [root@centos6 ~]# mesg n    #不允许系统用户将信息直接显示在你的屏幕上。</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Terminal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos6.9 安装详解</title>
      <link href="/2017/07/04/Linux-Centos6-9-Install/"/>
      <url>/2017/07/04/Linux-Centos6-9-Install/</url>
      <content type="html"><![CDATA[<p><code>CentOS</code>（<code>Community Enterprise Operating System</code>，中文意思是：社区企业操作系统）是<code>Linux</code>发行版之一，它是来自于<code>Red Hat Enterprise Linux</code>依照开放源代码规定释出的源代码所编译而成。</p><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-1.png" title="Centos"></center><a id="more"></a><h3 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h3><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-2.jpg" title="虚拟机配置"></center><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><h4 id="开启虚拟机后我们看到如下安装界面："><a href="#开启虚拟机后我们看到如下安装界面：" class="headerlink" title="开启虚拟机后我们看到如下安装界面："></a>开启虚拟机后我们看到如下安装界面：</h4><ol><li><p>安装或更新系统</p></li><li><p>安装显示卡驱动</p></li><li><p>系统修复</p></li><li><p>从硬盘启动</p></li><li><p>内存测试</p></li></ol><p>我们直接回车即可，即使你不动，默认也会在自动倒数结束后，开始安装。</p><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-3.jpg" title="开始安装"></center><h4 id="进入下一个界面测试安装媒体"><a href="#进入下一个界面测试安装媒体" class="headerlink" title="进入下一个界面测试安装媒体"></a>进入下一个界面测试安装媒体</h4><p>测试你的安装媒体是否损坏，按OK测试你的安装媒体（你所选的ISO文件），我们这里直接按SKIP跳过。</p><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-4.jpg" title="测试安装媒体"></center><h4 id="第一个界面"><a href="#第一个界面" class="headerlink" title="第一个界面"></a>第一个界面</h4><p>选右下角的“NEXT”，下一步。</p><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-5.jpg" title="第一个界面"></center><h4 id="然后就到了选语言，这里我们选英文。如图："><a href="#然后就到了选语言，这里我们选英文。如图：" class="headerlink" title="然后就到了选语言，这里我们选英文。如图："></a>然后就到了选语言，这里我们选英文。如图：</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-6.jpg" title="选语言"></center><h4 id="选择键盘"><a href="#选择键盘" class="headerlink" title="选择键盘"></a>选择键盘</h4><p>这个不要选错了，默认就可以。如图：</p><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-7.jpg" title="选择键盘"></center><h4 id="这里选择安装的存储设备"><a href="#这里选择安装的存储设备" class="headerlink" title="这里选择安装的存储设备"></a>这里选择安装的存储设备</h4><p>我想大家都是安装到本地硬盘吧，那就是上面这个了啦，第二个选线的意思是指定专用的存储设备（例如存储区域网络SAN），如图。选择：基本存储设备后，点击下一步。</p><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-8.jpg" title="安装的存储设备"></center><h4 id="弹出警告"><a href="#弹出警告" class="headerlink" title="弹出警告"></a>弹出警告</h4><p>会删除检测到的这个硬盘（204800MB）的所有数据，如果是多硬盘安装或升级安装的话，要小心注意了，全新安装的话，直接点击：是，如图。</p><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-9.jpg" title="弹出警告"></center><h4 id="这里是选择时区"><a href="#这里是选择时区" class="headerlink" title="这里是选择时区"></a>这里是选择时区</h4><p>我们选择：亚洲/中国/上海，如图。下一步。</p><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-10.jpg" title="选择时区"></center><h4 id="这里是设置根账户（root）的密码"><a href="#这里是设置根账户（root）的密码" class="headerlink" title="这里是设置根账户（root）的密码"></a>这里是设置根账户（root）的密码</h4><p>如图，如果你的密码过于简单，则会有另一个提示，我可以选择：无论如何都使用，如图：</p><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-11.jpg" title="设置根账户（root）的密码"></center><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-12.jpg" title="设置根账户（root）的密码"></center><h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-13.jpg" title="设置主机名"></center><h4 id="设置网络"><a href="#设置网络" class="headerlink" title="设置网络"></a>设置网络</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-14.jpg" title="设置网络"></center><h4 id="下面我们就到了分区：此处我们选择“创建自定义布局”"><a href="#下面我们就到了分区：此处我们选择“创建自定义布局”" class="headerlink" title="下面我们就到了分区：此处我们选择“创建自定义布局”"></a>下面我们就到了分区：此处我们选择“创建自定义布局”</h4><ul><li>使用所有空间</li><li>替换现有的Linux系统</li><li>缩小当前系统</li><li>使用自由空间</li><li>创建自定义布局</li></ul><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-15.jpg" title="分区"></center><h4 id="自定义分区："><a href="#自定义分区：" class="headerlink" title="自定义分区："></a>自定义分区：</h4><table><thead><tr><th>挂载点</th><th>大小</th><th>分区名称</th></tr></thead><tbody><tr><td>/</td><td>50G</td><td>/dev/sdba1</td></tr><tr><td>/boot</td><td>1G</td><td>/dev/sda2</td></tr><tr><td>/app</td><td>50G</td><td>/dev/sda3</td></tr><tr><td>swap</td><td>4G</td><td>/dev/sda4</td></tr></tbody></table><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-16.jpg" title="分区"></center><h4 id="创建-boot分区"><a href="#创建-boot分区" class="headerlink" title="创建/boot分区"></a>创建/boot分区</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-17.jpg" title="创建/boot分区"></center><h4 id="创建-分区"><a href="#创建-分区" class="headerlink" title="创建/分区"></a>创建/分区</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-18.jpg" title="创建/分区"></center><h4 id="创建-app分区"><a href="#创建-app分区" class="headerlink" title="创建/app分区"></a>创建/app分区</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-19.jpg" title="创建/app分区"></center><h4 id="创建交换分区"><a href="#创建交换分区" class="headerlink" title="创建交换分区"></a>创建交换分区</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-20.jpg" title="创建交换分区"></center><h4 id="分区图"><a href="#分区图" class="headerlink" title="分区图"></a>分区图</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-21.jpg" title="分区图"></center><h4 id="是否格式化"><a href="#是否格式化" class="headerlink" title="是否格式化"></a>是否格式化</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-22.jpg" title="是否格式化"></center><h4 id="点击下一步，将修改写入磁盘"><a href="#点击下一步，将修改写入磁盘" class="headerlink" title="点击下一步，将修改写入磁盘"></a>点击下一步，将修改写入磁盘</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-23.jpg" title="点击下一步，将修改写入磁盘。"></center><h4 id="然后，到了选择安装Centos组件的时候"><a href="#然后，到了选择安装Centos组件的时候" class="headerlink" title="然后，到了选择安装Centos组件的时候"></a>然后，到了选择安装Centos组件的时候</h4><p>这一步是选择机子是做什么用的，如图，分别是：</p><ol><li>桌面系统的安装</li><li>最小化桌面系统的安装</li><li>最小化安装</li><li>基本服务器的安装</li><li>数据库服务器的安装</li><li>WEB网页服务器的安装</li><li>虚拟主机的安装</li><li>软件开发工作站的安装</li></ol><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-24.jpg" title="选择安装Centos组件"></center><p>选择一种，系统会自动给你安装上一些需要的软件，当然也可以选择底下的：现在自定义，来选择要安装的组件。</p><h4 id="下一步后，就开始安装了。"><a href="#下一步后，就开始安装了。" class="headerlink" title="下一步后，就开始安装了。"></a>下一步后，就开始安装了。</h4><p>安装过程则根据你选择的组件内容所用的时间而不同……如图。</p><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-25.jpg" title="安装过程则根据你选择的组件内容所用的时间而不同"></center><h4 id="安装完成后就可以重启系统了，按一下“reboot”。如图："><a href="#安装完成后就可以重启系统了，按一下“reboot”。如图：" class="headerlink" title="安装完成后就可以重启系统了，按一下“reboot”。如图："></a>安装完成后就可以重启系统了，按一下“reboot”。如图：</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-26.jpg" title="完成后就可以重启系统了，按一下“reboot”"></center><h4 id="重启完成后，进入欢迎界面，点击“Forward”"><a href="#重启完成后，进入欢迎界面，点击“Forward”" class="headerlink" title="重启完成后，进入欢迎界面，点击“Forward”"></a>重启完成后，进入欢迎界面，点击“Forward”</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-27.jpg" title="重启完成后，进入欢迎界面，点击“Forward”"></center><h4 id="是否同意，点击“Forward”"><a href="#是否同意，点击“Forward”" class="headerlink" title="是否同意，点击“Forward”"></a>是否同意，点击“Forward”</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-28.jpg" title="是否同意，点击“Forward”"></center><h4 id="创建一个普通用户haiyun-也可以不创建"><a href="#创建一个普通用户haiyun-也可以不创建" class="headerlink" title="创建一个普通用户haiyun,也可以不创建"></a>创建一个普通用户haiyun,也可以不创建</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-29.jpg" title="创建一个普通用户haiyun,也可以不创建"></center><h4 id="设置时间，如果时间不对可以重新调整"><a href="#设置时间，如果时间不对可以重新调整" class="headerlink" title="设置时间，如果时间不对可以重新调整"></a>设置时间，如果时间不对可以重新调整</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-30.jpg" title="设置时间，如果时间不对可以重新调整"></center><h4 id="是否开启kdump"><a href="#是否开启kdump" class="headerlink" title="是否开启kdump"></a>是否开启kdump</h4><p>kdump是在系统崩溃、死锁或者死机的时候用来转储内存运行参数的一个工具和服务，此处就就不开启了。也可开启，根据需求自行选择</p><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-31.jpg" title="是否开启kdump"></center><h4 id="点击确认，需要重启"><a href="#点击确认，需要重启" class="headerlink" title="点击确认，需要重启"></a>点击确认，需要重启</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-32.jpg" title="点击确认，需要重启"></center><h4 id="重启完成，如下图可以愉快的登陆系统了。"><a href="#重启完成，如下图可以愉快的登陆系统了。" class="headerlink" title="重启完成，如下图可以愉快的登陆系统了。"></a>重启完成，如下图可以愉快的登陆系统了。</h4><center><img src="https://houhaiyun.github.io/img/images/Linux-Centos6-9-Install-33.jpg" title="重启完成"></center>]]></content>
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Centos6.9 安装详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos6.9 安装详解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用户空间和内核空间</title>
      <link href="/2017/07/03/Linux-User-space/"/>
      <url>/2017/07/03/Linux-User-space/</url>
      <content type="html"><![CDATA[<h3 id="用户空间：-User-space"><a href="#用户空间：-User-space" class="headerlink" title="用户空间： User space"></a>用户空间： User space</h3><ul><li>用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响</li><li>只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（<code>system call</code>），才能向内核发出指令 </li></ul><a id="more"></a><h3 id="内核空间：-Kernel-space"><a href="#内核空间：-Kernel-space" class="headerlink" title="内核空间： Kernel space"></a>内核空间： Kernel space</h3><ul><li>是 <code>Linux</code> 内核的运行空间</li></ul><ul><li>可以执行任意命令，调用系统的一切资源 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = "www.ihaiyun.cc" # 用户空间</span><br><span class="line">x = x + 2</span><br><span class="line">file.write(str) # 切换到内核空间</span><br><span class="line">y = x + 4 # 切换回用户空间</span><br></pre></td></tr></table></figure><p>上面代码中，第一行和第二行都是简单的赋值运算，在 <code>User space</code> 执行。第三行需要写入文件，就要切换到 <code>Kernel space</code>，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回 <code>User space</code>。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>内核空间可以访问所有的<code>CPU</code>指令和所有的内存空间、<code>I/O</code>空间。</li><li>用户空间只能访问有限的资源，若需要特殊权限，可以通过系统调用获取相应的资源。</li><li>用户空间允许页面中断，而内核空间则不允许。</li><li><code>x86 CPU</code>中用户空间是<code>0-3G</code>的地址范围，内核空间是<code>3G-4G</code>的地址范围。<code>x86_64 CPU</code>用户空间地址范围为<code>0x0000000000000000</code> – <code>0x00007fffffffffff</code>，内核地址空间为<code>0xffff880000000000</code>~最大地址。</li><li>内核空间和用户空间是针对线性地址空间的。</li><li>所有内核进（线）程共用一个地址空间，而用户进程都有各自的地址空间。</li></ul><center><img src="https://houhaiyun.github.io/img/images/Linux-User-space-1.png" title="用户空间和内核空间"></center><h3 id="单处程序时间统计使用time"><a href="#单处程序时间统计使用time" class="headerlink" title="单处程序时间统计使用time"></a>单处程序时间统计使用time</h3><p>如果想查看单个程序的耗时，一般使用<code>time</code>命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@blog ~]# time ifconfig </span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.18.252.210  netmask 255.255.0.0  broadcast 172.18.255.255</span><br><span class="line">        inet6 fe80::20c:29ff:fef8:15f5  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:f8:15:f5  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 16981  bytes 1356968 (1.2 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 93  bytes 23042 (22.5 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens34: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.8.135  netmask 255.255.255.0  broadcast 192.168.8.255</span><br><span class="line">        inet6 fe80::20c:29ff:fef8:15ff  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:f8:15:ff  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 11279  bytes 1036041 (1011.7 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 59808  bytes 130371849 (124.3 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255</span><br><span class="line">        ether 52:54:00:d7:0c:d1  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">real0m0.003s</span><br><span class="line">user0m0.001s</span><br><span class="line">sys0m0.002s</span><br></pre></td></tr></table></figure><p>程序名之前加上<code>time</code>命令，会在程序执行完毕以后，默认显示三行统计。</p><ul><li><code>real</code>：程序从开始运行到结束的全部时间，这是用户能感知到的时间，包括 CPU 切换去执行其他任务的时间。</li><li><code>user</code>：程序在 User space 执行的时间</li><li><code>sys</code>：程序在 Kernel space 执行的时间</li></ul><p><code>user</code>和<code>sys</code>之和，一般情况下，应该小于<code>real</code>。</p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="https://www.ait24.com/1256.html" target="_blank" rel="noopener">爱T网：linux中的内核空间Kernel space用户空间User space</a></p><p><a href="http://ilinuxkernel.com/?p=528" target="_blank" rel="noopener">Linux内核空间与用户空间</a></p>]]></content>
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> 用户空间和内核空间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用户空间和内核空间 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 发行版时间线</title>
      <link href="/2017/07/03/Linux-time/"/>
      <url>/2017/07/03/Linux-time/</url>
      <content type="html"><![CDATA[<center><img src="https://houhaiyun.github.io/img/images/Linux-time-1.png" title="Linux 发行版时间线"></center><a id="more"></a><p><strong>时间线请参见：</strong> <a href="https://en.wikipedia.org/wiki/File:Linux_Distribution_Timeline.svg" target="_blank" rel="noopener">Wikipedia</a></p>]]></content>
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux发行版时间线 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux发行版时间线 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见开源协议</title>
      <link href="/2017/07/02/Linux-open-source/"/>
      <url>/2017/07/02/Linux-open-source/</url>
      <content type="html"><![CDATA[<center><img src="https://houhaiyun.github.io/img/images/Linux-open-source-2.jpeg" title="Public License"></center><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>现今存在的开源协议很多，而经过<code>Open Source Initiative</code>组织通过批准的开源协议目前有 <a href="http://www.opensource.org/licenses/alphabetical" target="_blank" rel="noopener">80种</a>。我们在常见的开源协议如<code>BSD</code>, <code>Apache</code>, <code>GPL</code>, <code>LGPL</code>, <code>MIT</code>等都是<code>OSI</code>批准的协议。如果要开源自己的代码，最好也是选择这些被批准的开源协议。</p><p>这里我们来看几种最常用的开源协议及它们的适用范围，供那些准备开源或者使用开源产品的开发人员/厂家参考。</p><h3 id="BSD开源协议（original-BSD-license、FreeBSD-license、Original-BSD-license）"><a href="#BSD开源协议（original-BSD-license、FreeBSD-license、Original-BSD-license）" class="headerlink" title="BSD开源协议（original BSD license、FreeBSD license、Original BSD license）"></a>BSD开源协议（original BSD license、FreeBSD license、Original BSD license）</h3><p><code>BSD</code>开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p><p>但“为所欲为”的前提当你发布使用了<code>BSD</code>协议的代码，或则以<code>BSD</code>协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p><ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li></ul><p><code>BSD</code> 代码鼓励代码共享，但需要尊重代码作者的著作权。<code>BSD</code>由于允许使用者修改和重新发布代码，也允许使用或在<code>BSD</code>代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选<code>BSD</code>协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p><h3 id="Apache-Licence-2-0（Apache-License-Version-2-0、Apache-License-Version-1-1、Apache-License-Version-1-0）"><a href="#Apache-Licence-2-0（Apache-License-Version-2-0、Apache-License-Version-1-1、Apache-License-Version-1-0）" class="headerlink" title="Apache Licence 2.0（Apache License, Version 2.0、Apache License, Version 1.1、Apache License, Version 1.0）"></a>Apache Licence 2.0（Apache License, Version 2.0、Apache License, Version 1.1、Apache License, Version 1.0）</h3><p><code>Apache Licence</code>是著名的非盈利开源组织<code>Apache</code>采用的协议。该协议和<code>BSD</code>类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和<code>BSD</code>类似：</p><ul><li>需要给代码的用户一份<code>Apache Licence</code></li><li>如果你修改了代码，需要再被修改的文件中说明。</li><li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个<code>Notice</code>文件，则在<code>Notice</code>文件中需要带有<code>Apache Licence</code>。你可以在<code>Notice</code>中增加自己的许可，但不可以表现为对<code>Apache Licence</code>构成更改。</li></ul><p><code>Apache Licence</code>也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</p><h3 id="GPL（GNU-General-Public-License）通用性公开许可证"><a href="#GPL（GNU-General-Public-License）通用性公开许可证" class="headerlink" title="GPL（GNU General Public License）通用性公开许可证"></a>GPL（GNU General Public License）通用性公开许可证</h3><p>我们很熟悉的<code>Linux</code>就是采用了<code>GPL</code>。<code>GPL</code>协议和<code>BSD</code>, <code>Apache Licence</code>等鼓励代码重用的许可很不一样。<code>GPL</code>的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种<code>linux</code>，包括商业公司的<code>linux</code>和<code>linux</code>上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p><p><code>GPL</code>规定：只要这种修改文本在整体上或者其某个部分来源于遵循<code>GPL</code>的程序，该修改文本的 整体就必须按照GPL流通，不仅该修改文本的源码必须向社会公开，而且对于这种修改文本的流通不准许附加修改者自己作出的限制。因此，一项遵循<code>GPL</code>流通 的程序不能同非自由的软件合并。<code>GPL</code>所表达的这种流通规则称为<code>copyleft</code>，表示与<code>copyright</code>(版权)的概念“相左”。</p><h4 id="GPL协议最主要的几个原则："><a href="#GPL协议最主要的几个原则：" class="headerlink" title="GPL协议最主要的几个原则："></a>GPL协议最主要的几个原则：</h4><ul><li>确保软件自始至终都以开放源代码形式发布，保护开发成果不被窃取用作商业发售。任何一套软 件，只要其中使用了受 <code>GPL</code> 协议保护的第三方软件的源程序，并向非开发人员发布时，软件本身也就自动成为受 <code>GPL</code> 保护并且约束的实体。也就是说，此时它必须开放源代码。</li><li><code>GPL</code> 大致就是一个左侧版权（<code>Copyleft</code>，或译为“反版权”、“版权属左”、“版权所无”、“版责”等）的体现。你可以去掉所有原作的版权 信息，只要你保持开源，并且随源代码、二进制版附上 <code>GPL</code> 的许可证就行，让后人可以很明确地得知此软件的授权信息。GPL 精髓就是，只要使软件在完整开源 的情况下，尽可能使使用者得到自由发挥的空间，使软件得到更快更好的发展。</li><li>无论软件以何种形式发布，都必须同时附上源代码。例如在 <code>Web</code> 上提供下载，就必须在二进制版本（如果有的话）下载的同一个页面，清楚地提供源代码下载的链接。如果以光盘形式发布，就必须同时附上源文件的光盘。</li><li>开发或维护遵循 <code>GPL</code> 协议开发的软件的公司或个人，可以对使用者收取一定的服务费用。但还是一句老话——必须无偿提供软件的完整源代码，不得将源代码与服务做捆绑或任何变相捆绑销售。</li></ul><p><code>GPL</code> 只是规定用户在获取你的程序的时候必须可以获得源代码，但并没有规定必须免费，因此理论上说，你仍然可以收取费用。如果你的确需要发布你的程序，但又不想开源，规避 <code>GPL</code> 的方法是通过 <code>LPC</code> 或者 <code>RPC</code> 间接调用库里的接口。只要库和你的程序不运行在同一进程下，就不需要开源。</p><p>另外，你需要区分 <code>GPL</code> 和 <code>LGPL</code>。<code>LGPL</code> 的要求比 <code>GPL</code> 低，你可以动态链接一个 <code>LGPL</code> 的库而不需要开源你自己的程序，而 <code>GPL</code> 是不行的。</p><h4 id="LGPL（GNU-Lesser-General-Public-License）宽松公共许可证"><a href="#LGPL（GNU-Lesser-General-Public-License）宽松公共许可证" class="headerlink" title="LGPL（GNU Lesser General Public License）宽松公共许可证"></a>LGPL（GNU Lesser General Public License）宽松公共许可证</h4><p><code>LGPL</code>是<code>GPL</code>的一个为主要为类库使用设计的开源协议。和<code>GPL</code>要求任何使用/修改/衍生之<code>GPL</code>类库的的软件必须采用<code>GPL</code>协议不同。<code>LGPL</code>允许商业软件通过类库引用(<code>link</code>)方式使用<code>LGPL</code>类库而不需要开源商业软件的代码。这使得采用<code>LGPL</code>协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p>但是如果修改<code>LGPL</code>协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此<code>LGPL</code>协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以<code>LGPL</code>协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><p><code>GPL</code>/<code>LGPL</code>都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品</p><h4 id="AGPL-协议（Affero-General-Public-License）"><a href="#AGPL-协议（Affero-General-Public-License）" class="headerlink" title="AGPL 协议（Affero General Public License）"></a>AGPL 协议（Affero General Public License）</h4><p><code>GPL（2.x ~ 3.x）</code> 协议还有一个非常大的“漏洞”，就是软件“发布” 才必须开源。也就是说，我的软件不发布，即使使用 <code>GPL (2.x ~ 3.x)</code>也可以不用开源。随着以Google为代表的软件作为服务的互联网公司的兴起，它们的“不分发软件，为客户提供网络服务”的商业模式就不受GPL协议的约束</p><p>AGPL则增加了对此做法的约束：</p><pre><code>AGPL = GPL + 一条限制</code></pre><p>一条限制：如果使用<code>AGPL</code>许可的软件与用户通过网络进行交互，也需要提供源代码给用户，所有的修改也要给用户。</p><h3 id="MIT（MIT）"><a href="#MIT（MIT）" class="headerlink" title="MIT（MIT）"></a>MIT（MIT）</h3><p><code>MIT</code>是和<code>BSD</code>一样宽范的许可协议,作者只想保留版权,而无任何其他了限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的.</p><ul><li>被授权人有权利使用、复制、修改、合并、出版发行、散布、再授权及贩售软体及软体的副本。</li><li>被授权人可根据程式的需要修改授权条款为适当的内容。</li><li>在软件和软件的所有副本中都必须包含版权声明和许可声明</li></ul><h3 id="Zlib-Libpng协议"><a href="#Zlib-Libpng协议" class="headerlink" title="Zlib/Libpng协议"></a><code>Zlib</code>/<code>Libpng</code>协议</h3><p>基于该软件的原样使用，作者不负责使用该软件照成的任何损失。</p><p>该软件修改后的版本将受到以下限制：</p><ul><li>不能歪曲原软件的著作权</li><li>修改后的软件不能歪曲为原版软件</li><li>不能删除源码中的协议许可内容</li></ul><p>如果发布二进制代码可以不用附上源代码。</p><h3 id="MPL-The-Mozilla-Public-License-Mozilla公共许可证"><a href="#MPL-The-Mozilla-Public-License-Mozilla公共许可证" class="headerlink" title="MPL(The Mozilla Public License)Mozilla公共许可证"></a>MPL(The Mozilla Public License)Mozilla公共许可证</h3><p><code>MPL</code>是<code>The Mozilla Public License</code>的简写，是1998年初<code>Netscape</code>的<code>Mozilla</code>小组为其开源软件项目设计的软件许可证。<code>MPL</code>许可证出现的最重要原因就是，<code>Netscape</code>公司认为<code>GPL</code>许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。同著名的<code>GPL</code>许可证和<code>BSD</code>许可证相比，<code>MPL</code>在许多权利与义务的约定方面与它们相同（因为都是符合<code>OSIA</code>认定的开源软件许可证）。但是，相比而言<code>MPL</code>还有以下几个显著的不同之处:</p><ul><li><code>MPL</code>虽然要求对于经<code>MPL</code>许可证发布的源代码的修改也要以<code>MPL</code>许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在<code>MPL</code> 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着<code>MPL</code>允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以<code>MPL</code>许可证的形式对外许可外，源代码库中的源代码就可以不用<code>MPL</code>许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口。</li><li><code>MPL</code>许可证第三条第7款中允许被许可人将经过<code>MPL</code>许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。</li><li>对软件专利的态度，<code>MPL</code>许可证不像<code>GPL</code>许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。</li><li>对源代码的定义而在<code>MPL</code>（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘<code>Script</code>’），或者不是与初始源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。”<ul><li><code>MPL</code>许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。</li></ul></li></ul><h4 id="MPL与其他协议的兼容性"><a href="#MPL与其他协议的兼容性" class="headerlink" title="MPL与其他协议的兼容性"></a>MPL与其他协议的兼容性</h4><p>不像那些较严格的<code>Copyleft</code>许可证，使用<code>MPL</code>授权的源代码可以在一个复杂的软件中与任何其他的许可协议相结合，只要仍满足<code>MPL</code>许可协议中3.3节的规定即可。这意味着在一份给定的源文件里面，必须全部的源代码都以MPL授权，否则就所有源代码均以其他方式授权。</p><p><code>MPL</code>第二版与<code>Apache</code>许可证以及<code>GPL</code>第二版或更新、<code>LGPL2.1</code>版或更新，及<code>AGPL</code>第三版或更新兼容。而1.1版因为有“一些复杂的限制”造成与<code>GPL</code>的不兼容（从而阻止升级到<code>MPL 2.0</code>）。</p><h3 id="GPL、BSD、MIT、Mozilla、Apache和LGPL之中做选择"><a href="#GPL、BSD、MIT、Mozilla、Apache和LGPL之中做选择" class="headerlink" title="GPL、BSD、MIT、Mozilla、Apache和LGPL之中做选择"></a>GPL、BSD、MIT、Mozilla、Apache和LGPL之中做选择</h3><center><img src="https://houhaiyun.github.io/img/images/Linux-open-source-1.jpg" title="GPL、BSD、MIT、Mozilla、Apache和LGPL之中做选择"></center><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="http://ewen0930.github.io/2016/11/open-source-licenses/" target="_blank" rel="noopener">本文转自：Hello EWEN</a></p>]]></content>
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> 常见开源协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见开源协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 历史?</title>
      <link href="/2017/07/02/Linux-history/"/>
      <url>/2017/07/02/Linux-history/</url>
      <content type="html"><![CDATA[<h3 id="Linux之前的UNIX历史："><a href="#Linux之前的UNIX历史：" class="headerlink" title="Linux之前的UNIX历史："></a><code>Linux</code>之前的<code>UNIX</code>历史：</h3><ul><li>1969年以前伟大的梦想-贝尔实验室 （<code>Bell Labs</code>）通用电气（<code>General Electric</code>）和麻省理工学院（<code>MIT</code>）的<code>Multics</code>系统。</li></ul><ul><li>1969年<code>Ken Thompson</code>使用汇编语言<code>B</code>语言<code>File Server System</code>。<a id="more"></a></li></ul><ul><li>1973年<code>UNIX</code>正式诞生，<code>Ritchie</code>等人以<code>C</code>语言写出第一个正式内核。</li></ul><ul><li>1977年重要的<code>UNIX</code>分支-<code>BSD</code>诞生。</li></ul><pre><code>伯克利大学的Bill Joy在取得了UNIX的内核源码后，修改成为自己的版本，并重新命名为Berkeley Software Distribution(BSD)。BSD是UNIX很重要的一个分支，Bill Joy也是Sun这家公司的创办者。</code></pre><ul><li>1979年重要的<code>System V</code>架构与版权声明。</li></ul><pre><code>由于当时UNIX的高度可移植性与强大的性能，也没有版权纠纷，所以很多商业公司开始了UNIX操作系统的开发。例如：AT&amp;A自家的System V、IBM的AIX等。不过因为AT&amp;T由于商业的考略，于是想将UNIX的版权收回去。因此，AT&amp;T在1979年发行的第七版UNIX中，特别提到了“不可对学生提供源码”的严格限制。</code></pre><ul><li><strong>1984年</strong>：</li></ul><pre><code>X86架构的Minix操作系统诞生。关于1979的版权声明中，影响最大的当然就是学校里的教授了。于是荷兰阿姆斯特丹自由大学计算机科学系Andrew S. Tanenbaum开始编写内核程序，到了1986年终于完成，并于次年出版Minix相关书籍，同时雨新闻组（BBS及News）相结合。    - Richard Stallman发起GNU项目和自由软件基金会。    创建开源的UNIX实用工具版本    创建通用公共许可证（GPL）    开源软件许可实施原则</code></pre><ul><li>1991年：<code>Linus Torvalds</code>发布<code>Linux</code>创建开放源码，类<code>Unix</code>的内核，在<code>GPL</code>下发布。</li></ul><h3 id="老照片哦"><a href="#老照片哦" class="headerlink" title="老照片哦(^_^)"></a>老照片哦(^_^)</h3><h4 id="Ken-Thompson-和Dennis-Ritchie"><a href="#Ken-Thompson-和Dennis-Ritchie" class="headerlink" title="Ken Thompson 和Dennis Ritchie"></a><center>Ken Thompson 和Dennis Ritchie</center></h4><center><img src="https://houhaiyun.github.io/img/images/Linux-history-1.jpg" title="Ken Thompson 和Dennis Ritchie"></center><h4 id="Richard-Matthew-Stallman"><a href="#Richard-Matthew-Stallman" class="headerlink" title="Richard Matthew Stallman"></a><center>Richard Matthew Stallman</center></h4><center><img src="https://houhaiyun.github.io/img/images/Linux-history-2.jpg" title="Richard Matthew Stallman"></center><h4 id="Linus-Torvalds-1991"><a href="#Linus-Torvalds-1991" class="headerlink" title="Linus Torvalds, 1991"></a><center>Linus Torvalds, 1991</center></h4><center><img src="https://houhaiyun.github.io/img/images/Linux-history-3.jpg" title="Linus Torvalds, 1991"></center><h4 id="Linus-Torvalds给Minix新闻组的历史消息"><a href="#Linus-Torvalds给Minix新闻组的历史消息" class="headerlink" title="Linus Torvalds给Minix新闻组的历史消息"></a><center>Linus Torvalds给Minix新闻组的历史消息</center></h4><p><code>Linus Torvalds</code> 在芬兰赫尔辛基开始了 <code>Linux</code> 内核开发，他是为他的硬件-<code>Intel 30386 CPU</code>编写的程序。他也使用<code>Minix</code>和<code>GNU C</code>编译器。下面是<code>Linus Torvalds</code>给<code>Minix</code>新闻组的历史消息：</p><center><img src="https://houhaiyun.github.io/img/images/Linux-history-4.jpg" title="Linus Torvalds给Minix新闻组的历史消息"></center><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="https://linux.cn/article-6469-1.html" target="_blank" rel="noopener">老照片：Linux的24 年历史，一步一个脚印</a></p><p><a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥<code>linux</code>私房菜</a></p>]]></content>
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> Linux历史 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux历史 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么Linux？</title>
      <link href="/2017/07/01/Linux/"/>
      <url>/2017/07/01/Linux/</url>
      <content type="html"><![CDATA[<h3 id="什么是linux？"><a href="#什么是linux？" class="headerlink" title="什么是linux？"></a>什么是linux？</h3><p><code>Linux</code>是一种自由和开放源代码的类<code>UNIX</code>操作系统。目前运用领域最广泛、使用人数最多的操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布。在加上用户空间的应用程序之后，成为<code>Linux</code>操作系统。<code>Linux</code>也是自由软件和开放源代码软件发展中最著名的例子。只要遵循<code>GNU</code>通用公共许可证，任何个人和机构都可以自由地使用<code>Linux</code>的所有底层源代码，也可以自由地修改和再发布。大多数<code>Linux</code>系统还包括像提供<code>GUI</code>的<code>X Window</code>之类的程序。除了一部分专家之外，大多数人都是直接使用<code>Linux</code>发行版，而不是自己选择每一样组件或自行设置。<br><a id="more"></a></p><p><code>Linux</code>严格来说是单指操作系统的内核，因操作系统中包含了许多用户图形接口和其他实用工具。如今<code>Linux</code>常用来指基于<code>Linux</code>的完整操作系统，内核则改以<code>Linux</code>内核称之。由于这些支持用户空间的系统工具和库主要由理查德·斯托曼于1983年发起的<code>GNU</code>计划提供，自由软件基金会提议将其组合系统命名为<code>GNU/Linux</code>，但<code>Linux</code>不属于<code>GNU</code>计划，这个名称并没有得到社区的一致认同。</p><h3 id="linux吉祥物TUX"><a href="#linux吉祥物TUX" class="headerlink" title="linux吉祥物TUX"></a><code>linux</code>吉祥物<code>TUX</code></h3><p><code>Tux</code>是<code>Linux</code>官方的吉祥物，于1996年由<code>Larry Ewing</code>创造</p><center><img src="https://houhaiyun.github.io/img/images/Linux-logo.png" title="Linux 吉祥物"></center><h4 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h4><p><a href="https://zh.wikipedia.org/wiki/" target="_blank" rel="noopener">维基百科：Linux</a></p>]]></content>
      
      <categories>
          
          <category> Linux基础 </category>
          
          <category> 什么Linux？ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 什么Linux？ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>冯.诺依曼体系结构</title>
      <link href="/2017/07/01/Linux-fengnuoyiman/"/>
      <url>/2017/07/01/Linux-fengnuoyiman/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>冯·诺伊曼结构</strong>（英语：<code>von Neumann architecture</code>），也称<strong>冯·诺伊曼模型</strong>（<code>Von Neumann model</code>）或<strong>普林斯顿结构</strong>（<code>Princeton architecture</code>），是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。<br><a id="more"></a></p><h3 id="冯诺依曼体系结构提出"><a href="#冯诺依曼体系结构提出" class="headerlink" title="冯诺依曼体系结构提出"></a>冯诺依曼体系结构提出</h3><p>1946年数学家冯·诺依曼于提出：计算机硬件由运算器、控制器、存储器、输入设备、输出设备组成。</p><center><img src="https://houhaiyun.github.io/img/images/fengnuoyiman-jiegou-1.jpg" title="冯.诺依曼体系结构"></center><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>以运算单元为中心</li><li>采用存储程序原理</li><li>存储器是按地址访问、线性编址的空间</li><li>控制流由指令流产生</li><li>指令由操作码和地址码组成</li><li>数据以二进制编码</li></ol><h3 id="冯·诺伊曼瓶颈"><a href="#冯·诺伊曼瓶颈" class="headerlink" title="冯·诺伊曼瓶颈"></a>冯·诺伊曼瓶颈</h3><p>将CPU与内存分开并非十全十美，反而会导致所谓的冯·诺伊曼瓶颈（von Neumann bottleneck）：在CPU与内存之间的流量（数据传输率）与内存的容量相比起来相当小，在现代电脑中，流量与CPU的工作效率相比之下非常小，在某些情况下（当CPU需要在巨大的数据上运行一些简单指令时），数据流量就成了整体效率非常严重的限制。CPU将会在数据输入或输出内存时闲置。由于CPU速度远大于内存读写速率，因此瓶颈问题越来越严重。</p><h3 id="冯诺依曼"><a href="#冯诺依曼" class="headerlink" title="冯诺依曼"></a>冯诺依曼</h3><center><img src="https://houhaiyun.github.io/img/images/fengnuoyiman-jiegou-2.jpg" title="冯.诺依曼"></center><h4 id="致谢："><a href="#致谢：" class="headerlink" title="致谢："></a>致谢：</h4><p><a href="https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84#.E7.90.86.E8.AB.96" target="_blank" rel="noopener">维基百科：冯·诺伊曼结构</a></p>]]></content>
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
          <category> 冯.诺依曼体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冯.诺依曼体系结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ABI和API</title>
      <link href="/2017/07/01/Linux-ABI-API/"/>
      <url>/2017/07/01/Linux-ABI-API/</url>
      <content type="html"><![CDATA[<h3 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h3><p>应用二进制接口（英语：<code>application binary interface</code>，缩写为 <code>ABI</code>）描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。允许编译好的目标代码在使用兼容<code>ABI</code>的系统中无需改动就能运行。<br><a id="more"></a></p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>应用程序接口（英语：<code>Application Programming Interface</code>，简称：<code>API</code>），又称为应用编程接口，就是软件系统不同组成部分衔接的约定。</p><p>API定义了源代码和库之间的接口，因此同样的源代码可以在支持这个API的任何系统中编译。</p><center><img src="https://houhaiyun.github.io/img/images/ABI-API.gif" title="ABI and API"></center><h4 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h4><p><a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">维基百科：应用二进制接口</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">维基百科：应用程序接口</a></p>]]></content>
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
          <category> ABI和API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABI和API </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
